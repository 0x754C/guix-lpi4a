From e0fde828b98ae61c9cb36cebe88325d0776dabf0 Mon Sep 17 00:00:00 2001
From: Lu Hui <luhui@sipeed.com>
Date: Fri, 22 Sep 2023 15:39:25 +0800
Subject: [PATCH 3/3] drivers: wireless: upgrade aic8800 from 2023_0207_1041 to
 2023_0904_1725

---
 drivers/net/wireless/aic8800/Kconfig          |   1 +
 drivers/net/wireless/aic8800/Makefile         |   0
 .../net/wireless/aic8800/aic8800_bsp/Makefile |  34 +-
 .../aic8800/aic8800_bsp/aic8800d80_compat.c   | 190 ++---
 .../aic8800/aic8800_bsp/aic8800d80_compat.h   |   4 +-
 .../aic8800/aic8800_bsp/aic8800dc_compat.c    | 367 ++++++++--
 .../aic8800/aic8800_bsp/aic8800dc_compat.h    |   9 +
 .../aic8800/aic8800_bsp/aic_bsp_driver.c      | 364 ++++++++--
 .../aic8800/aic8800_bsp/aic_bsp_driver.h      |  38 +-
 .../aic8800/aic8800_bsp/aic_bsp_export.h      |  16 +
 .../aic8800/aic8800_bsp/aic_bsp_main.c        |  23 +-
 .../wireless/aic8800/aic8800_bsp/aicsdio.c    | 106 ++-
 .../wireless/aic8800/aic8800_bsp/aicsdio.h    |   1 +
 .../aic8800/aic8800_bsp/aicsdio_txrxif.c      |   2 +-
 .../aic8800/aic8800_bsp/aicsdio_txrxif.h      |   0
 .../aic8800_bsp/aicwf_firmware_array.c        |   0
 .../aic8800_bsp/aicwf_firmware_array.h        |   0
 .../aic8800/aic8800_bsp/aicwf_txq_prealloc.c  |  62 ++
 .../aic8800/aic8800_bsp/aicwf_txq_prealloc.h  |   4 +
 .../net/wireless/aic8800/aic8800_bsp/md5.c    |   0
 .../net/wireless/aic8800/aic8800_bsp/md5.h    |   0
 .../aic8800/aic8800_bsp/rwnx_version_gen.h    |   2 +-
 .../wireless/aic8800/aic8800_btlpm/Kconfig    |   0
 .../wireless/aic8800/aic8800_btlpm/Makefile   |   0
 .../aic8800/aic8800_btlpm/aic8800_btlpm.c     |   0
 .../aic8800_btlpm/aic_bluetooth_main.c        |   0
 .../aic8800/aic8800_btlpm/aic_bsp_export.h    |   0
 .../net/wireless/aic8800/aic8800_btlpm/lpm.c  |  20 +-
 .../net/wireless/aic8800/aic8800_btlpm/lpm.h  |   0
 .../wireless/aic8800/aic8800_btlpm/rfkill.c   |   0
 .../wireless/aic8800/aic8800_btlpm/rfkill.h   |   0
 .../net/wireless/aic8800/aic8800_fdrv/Kconfig |   1 +
 .../wireless/aic8800/aic8800_fdrv/Makefile    |  28 +-
 .../aic8800/aic8800_fdrv/aic_br_ext.c         |   0
 .../aic8800/aic8800_fdrv/aic_br_ext.h         |   0
 .../aic8800/aic8800_fdrv/aic_bsp_export.h     |   8 +
 .../aic8800/aic8800_fdrv/aic_vendor.c         |  15 +-
 .../aic8800/aic8800_fdrv/aic_vendor.h         |   1 +
 .../aic8800_fdrv/aicwf_compat_8800d80.c       |   2 +-
 .../aic8800_fdrv/aicwf_compat_8800d80.h       |   0
 .../aic8800_fdrv/aicwf_compat_8800dc.c        | 356 +++++++--
 .../aic8800_fdrv/aicwf_compat_8800dc.h        |   5 +
 .../aic8800/aic8800_fdrv/aicwf_debug.h        |   4 +
 .../aic8800/aic8800_fdrv/aicwf_rx_prealloc.c  |   0
 .../aic8800/aic8800_fdrv/aicwf_rx_prealloc.h  |   0
 .../aic8800/aic8800_fdrv/aicwf_sdio.c         | 454 +++++++++---
 .../aic8800/aic8800_fdrv/aicwf_sdio.h         |   7 +-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |  24 +-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.h       |   2 +
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c |   0
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |   0
 .../wireless/aic8800/aic8800_fdrv/hal_desc.h  |   0
 .../aic8800/aic8800_fdrv/ipc_compat.h         |   0
 .../wireless/aic8800/aic8800_fdrv/ipc_host.c  |   0
 .../wireless/aic8800/aic8800_fdrv/ipc_host.h  |   0
 .../aic8800/aic8800_fdrv/ipc_shared.h         |   0
 .../wireless/aic8800/aic8800_fdrv/lmac_mac.h  |   0
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  | 108 ++-
 .../aic8800/aic8800_fdrv/lmac_types.h         |   0
 .../net/wireless/aic8800/aic8800_fdrv/md5.c   |   0
 .../net/wireless/aic8800/aic8800_fdrv/md5.h   |   0
 .../aic8800/aic8800_fdrv/reg_access.h         |   0
 .../net/wireless/aic8800/aic8800_fdrv/regdb.c |   0
 .../aic8800/aic8800_fdrv/rwnx_bfmer.c         |   0
 .../aic8800/aic8800_fdrv/rwnx_bfmer.h         |   0
 .../aic8800/aic8800_fdrv/rwnx_cfgfile.c       |   0
 .../aic8800/aic8800_fdrv/rwnx_cfgfile.h       |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |   4 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.h |   4 +-
 .../aic8800/aic8800_fdrv/rwnx_compat.h        |   2 +-
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       |  96 ++-
 .../aic8800/aic8800_fdrv/rwnx_debugfs.h       |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |  23 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_dini.c |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_dini.h |   0
 .../aic8800/aic8800_fdrv/rwnx_events.h        |   0
 .../aic8800/aic8800_fdrv/rwnx_fw_trace.c      |   0
 .../aic8800/aic8800_fdrv/rwnx_fw_trace.h      |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.c  |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_gki.h  |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_irqs.c |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_irqs.h |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c | 674 +++++++++++++++---
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.h |   3 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_mesh.c |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_mesh.h |   0
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |   7 +-
 .../aic8800/aic8800_fdrv/rwnx_mod_params.h    |   0
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |  88 ++-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.h        |   0
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        | 245 ++++++-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |   2 +
 .../aic8800/aic8800_fdrv/rwnx_mu_group.c      |   0
 .../aic8800/aic8800_fdrv/rwnx_mu_group.h      |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_pci.c  |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_pci.h  |   0
 .../aic8800/aic8800_fdrv/rwnx_platform.c      | 170 ++++-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |   5 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_prof.h |   0
 .../aic8800/aic8800_fdrv/rwnx_radar.c         |   0
 .../aic8800/aic8800_fdrv/rwnx_radar.h         |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |  33 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.h   |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_strs.c |  12 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_strs.h |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tdls.c |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tdls.h |   0
 .../aic8800/aic8800_fdrv/rwnx_testmode.c      |   0
 .../aic8800/aic8800_fdrv/rwnx_testmode.h      |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   |  18 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.h   |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.c  |  11 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.h  |   0
 .../aic8800/aic8800_fdrv/rwnx_utils.c         |   0
 .../aic8800/aic8800_fdrv/rwnx_utils.h         |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_v7.c   |   0
 .../wireless/aic8800/aic8800_fdrv/rwnx_v7.h   |   0
 .../aic8800/aic8800_fdrv/rwnx_version.h       |   0
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |   2 +-
 .../aic8800/aic8800_fdrv/rwnx_wakelock.c      |  82 +++
 .../aic8800/aic8800_fdrv/rwnx_wakelock.h      |  21 +
 .../wireless/aic8800/aic8800_fdrv/sdio_host.c |   0
 .../wireless/aic8800/aic8800_fdrv/sdio_host.h |   0
 .../wireless/aic8800/aic8800_fdrv/usb_host.c  |   0
 .../wireless/aic8800/aic8800_fdrv/usb_host.h  |   0
 125 files changed, 3102 insertions(+), 658 deletions(-)
 mode change 100755 => 100644 drivers/net/wireless/aic8800/Kconfig
 mode change 100755 => 100644 drivers/net/wireless/aic8800/Makefile
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/Makefile
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/md5.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/md5.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/Kconfig
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/Makefile
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/aic_bluetooth_main.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/aic_bsp_export.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/lpm.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/lpm.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/Kconfig
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/md5.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/md5.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c
 mode change 100755 => 100644 drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h

diff --git a/drivers/net/wireless/aic8800/Kconfig b/drivers/net/wireless/aic8800/Kconfig
old mode 100755
new mode 100644
index e846cbfdb..90f674b9f
--- a/drivers/net/wireless/aic8800/Kconfig
+++ b/drivers/net/wireless/aic8800/Kconfig
@@ -7,6 +7,7 @@ config AIC_WLAN_SUPPORT
 config AIC_FW_PATH
 	depends on AIC_WLAN_SUPPORT
 	string "Firmware & config file path"
+	#default "/vendor/etc/firmware"
 	default "/lib/firmware/aic8800"
 	help
 	  Path to the firmware & config file.
diff --git a/drivers/net/wireless/aic8800/Makefile b/drivers/net/wireless/aic8800/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/Makefile b/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
old mode 100755
new mode 100644
index c57b67b1c..b311153cb
--- a/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
@@ -1,5 +1,8 @@
 CONFIG_SDIO_SUPPORT := y
-CONFIG_SDIO_PWRCTRL := n
+CONFIG_SDIO_PWRCTRL := y
+#CONFIG_AIC_FW_PATH = "/vendor/etc/firmware"
+CONFIG_AIC_FW_PATH = "/lib/firmware/aic8800"
+export CONFIG_AIC_FW_PATH
 ccflags-y += -DCONFIG_AIC_FW_PATH=\"$(CONFIG_AIC_FW_PATH)\"
 
 MODULE_NAME := aic8800_bsp
@@ -14,14 +17,26 @@ CONFIG_MCU_MESSAGE = n
 CONFIG_FIRMWARE_ARRAY = n
 # Need to set fw path in BOARD_KERNEL_CMDLINE
 CONFIG_USE_FW_REQUEST = n
-
+CONFIG_FDRV_NO_REG_SDIO = n
+CONFIG_VRF_DCDC_MODE = y
+CONFIG_OOB = n
+CONFIG_PREALLOC_TXQ = y
+CONFIG_ONE_TXQ = n
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
 
 ccflags-$(CONFIG_GPIO_WAKEUP) += -DCONFIG_GPIO_WAKEUP
 ccflags-$(CONFIG_LINK_DET_5G) += -DCONFIG_LINK_DET_5G
 ccflags-$(CONFIG_MCU_MESSAGE) += -DCONFIG_MCU_MESSAGE
 ccflags-$(CONFIG_FIRMWARE_ARRAY) += -DCONFIG_FIRMWARE_ARRAY
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
-
+ccflags-$(CONFIG_FDRV_NO_REG_SDIO) += -DCONFIG_FDRV_NO_REG_SDIO
+ccflags-$(CONFIG_VRF_DCDC_MODE) += -DCONFIG_VRF_DCDC_MODE
+ccflags-$(CONFIG_OOB) += -DCONFIG_OOB
+ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
+ccflags-$(CONFIG_ONE_TXQ)  += -DCONFIG_ONE_TXQ
+ccflags-$(CONFIG_DPD)  += -DCONFIG_DPD
+ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
 
 obj-m := $(MODULE_NAME).o
 $(MODULE_NAME)-y := \
@@ -33,8 +48,10 @@ $(MODULE_NAME)-y := \
 	aicsdio_txrxif.o \
 	md5.o
 
+$(MODULE_NAME)-$(CONFIG_PREALLOC_TXQ)     += aicwf_txq_prealloc.o
+
 ifeq ($(CONFIG_FIRMWARE_ARRAY),y)
-$(MODULE_NAME)-y +=	aicwf_firmware_array.o 
+$(MODULE_NAME)-y +=	aicwf_firmware_array.o
 endif
 
 # Platform support list
@@ -58,10 +75,17 @@ ccflags-$(CONFIG_PLATFORM_ROCKCHIP) += -DCONFIG_PLATFORM_ROCKCHIP
 #KDIR  ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
 #ARCH ?= arm
 #CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
+#KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
+#KDIR ?= /home/yaya/E/Rockchip/3566/oudu/kernel
+#KDIR ?= /home/yaya/E/Rockchip/3566/shengteng/kernel
+#ARCH ?= arm64
+#CROSS_COMPILE ?= ~/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+#KDIR ?= /home/yaya/E/Rockchip/3328/Android9/SDK/kernel/
+#ARCH ?= arm64
+#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3328/Android9/SDK/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
 ARCH ?= arm64
 CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-
 endif
 
 ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
old mode 100755
new mode 100644
index 7e9212ef5..bf34109db
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
@@ -4,23 +4,26 @@
 extern struct aicbsp_info_t aicbsp_info;
 extern int adap_test;
 
+typedef u32 (*array2_tbl_t)[2];
+
+#define AIC_PATCH_MAGIG_NUM     0x48435450 // "PTCH"
+#define AIC_PATCH_MAGIG_NUM_2   0x50544348 // "HCTP"
+#define AIC_PATCH_BLOCK_MAX     4
+
+typedef struct {
+    uint32_t magic_num;
+    uint32_t pair_start;
+    uint32_t magic_num_2;
+    uint32_t pair_count;
+    uint32_t block_dst[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_src[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_size[AIC_PATCH_BLOCK_MAX]; // word count
+} aic_patch_t;
+
+#define AIC_PATCH_OFST(mem) ((size_t) &((aic_patch_t *)0)->mem)
+#define AIC_PATCH_ADDR(mem) ((u32)(aic_patch_str_base + AIC_PATCH_OFST(mem)))
+
 u32 aicbsp_syscfg_tbl_8800d80[][2] = {
-/*
-	{0x40500014, 0x00000101}, // 1)
-	{0x40500018, 0x00000109}, // 2)
-	{0x40500004, 0x00000010}, // 3) the order should not be changed
-
-	// def CONFIG_PMIC_SETTING
-	// U02 bootrom only
-	{0x40040000, 0x00001AC8}, // 1) fix panic
-	{0x40040084, 0x00011580},
-	{0x40040080, 0x00000001},
-	{0x40100058, 0x00000000},
-
-	{0x50000000, 0x03220204}, // 2) pmic interface init
-	{0x50019150, 0x00000002}, // 3) for 26m xtal, set div1
-	{0x50017008, 0x00000000}, // 4) stop wdg
-*/
 };
 
 int aicbsp_system_config_8800d80(struct aic_sdio_dev *sdiodev)
@@ -39,76 +42,68 @@ int aicbsp_system_config_8800d80(struct aic_sdio_dev *sdiodev)
 
 
 u32 adaptivity_patch_tbl_8800d80[][2] = {
-/*
-	{0x0004, 0x0000320A}, //linkloss_thd
-    {0x0094, 0x00000000}, //ac_param_conf
-	{0x00F8, 0x00010138}, //tx_adaptivity_en
-*/
+	{0x000C, 0x0000320A}, //linkloss_thd
+	{0x009C, 0x00000000}, //ac_param_conf
+	{0x0168, 0x00010000}, //tx_adaptivity_en
 };
 
 u32 patch_tbl_8800d80[][2] = {
-/*
-#if !defined(CONFIG_LINK_DET_5G)
-    {0x0104, 0x00000000}, //link_det_5g
-#endif
-#if defined(CONFIG_MCU_MESSAGE)
-    {0x004c, 0x0000004B}, //pkt_cnt_1724=0x4B
-    {0x0050, 0x0011FC00}, //ipc_base_addr
-#endif
-*/
+	#ifdef USE_5G
+	{0x00b4, 0xf3010001},
+	#else
+	{0x00b4, 0xf3010000},
+	#endif
 };
 
-u32 syscfg_tbl_masked_8800d80[][3] = {
-	{0x40506024, 0x000000FF, 0x000000DF}, // for clk gate lp_level
-};
-
-u32 rf_tbl_masked_8800d80[][3] = {
-	{0x40344058, 0x00800000, 0x00000000},// pll trx
+#ifdef CONFIG_OOB
+// for 8800d40/d80     map data1 isr to gpiob1
+u32 gpio_cfg_tbl_8800d40d80[][2] = {
+    {0x40504084, 0x00000006},
+    {0x40500040, 0x00000000},
+    {0x40100030, 0x00000001},
+    {0x40241020, 0x00000001},
+    {0x40240030, 0x00000004},
+    {0x40240020, 0x03020700},
 };
+#endif
 
 int aicwifi_sys_config_8800d80(struct aic_sdio_dev *sdiodev)
 {
-	int ret, cnt;
-	int syscfg_num = sizeof(syscfg_tbl_masked_8800d80) / sizeof(u32) / 3;
-	for (cnt = 0; cnt < syscfg_num; cnt++) {
-		ret = rwnx_send_dbg_mem_mask_write_req(sdiodev,
-			syscfg_tbl_masked_8800d80[cnt][0], syscfg_tbl_masked_8800d80[cnt][1], syscfg_tbl_masked_8800d80[cnt][2]);
+#ifdef CONFIG_OOB
+    int ret, cnt;
+	int gpiocfg_num = sizeof(gpio_cfg_tbl_8800d40d80) / sizeof(u32) / 2;
+	for (cnt = 0; cnt < gpiocfg_num; cnt++) {
+		ret = rwnx_send_dbg_mem_write_req(sdiodev, gpio_cfg_tbl_8800d40d80[cnt][0], gpio_cfg_tbl_8800d40d80[cnt][1]);
 		if (ret) {
-			printk("%x mask write fail: %d\n", syscfg_tbl_masked_8800d80[cnt][0], ret);
+			printk("%x write fail: %d\n", gpio_cfg_tbl_8800d40d80[cnt][0], ret);
 			return ret;
 		}
 	}
-
-	ret = rwnx_send_dbg_mem_mask_write_req(sdiodev,
-				rf_tbl_masked_8800d80[0][0], rf_tbl_masked_8800d80[0][1], rf_tbl_masked_8800d80[0][2]);
-	if (ret) {
-		printk("rf config %x write fail: %d\n", rf_tbl_masked_8800d80[0][0], ret);
-		return ret;
-	}
+#endif
 
 	return 0;
 }
 
 int aicwifi_patch_config_8800d80(struct aic_sdio_dev *sdiodev)
 {
-	const u32 rd_patch_addr = RAM_FMAC_FW_ADDR + 0x0180;
-	u32 config_base;
-	uint32_t start_addr = 0x1e6000;
+	const u32 rd_patch_addr = RAM_FMAC_FW_ADDR + 0x0198;
+	u32 aic_patch_addr;
+	u32 config_base, aic_patch_str_base;
+	uint32_t start_addr = 0x0016F800;
 	u32 patch_addr = start_addr;
-	u32 patch_num = sizeof(patch_tbl_8800d80)/4;
+	u32 patch_cnt = sizeof(patch_tbl_8800d80)/sizeof(u32)/2;
 	struct dbg_mem_read_cfm rd_patch_addr_cfm;
-	u32 patch_addr_reg = 0x1e5318;
-	u32 patch_num_reg = 0x1e531c;
 	int ret = 0;
-	u16 cnt = 0;
-	int tmp_cnt = 0;
-	int adap_patch_num = 0;
+	int cnt = 0;
+	//adap test
+	int adap_patch_cnt = 0;
 
-	if (aicbsp_info.cpmode == AICBSP_CPMODE_TEST) {
-		patch_addr_reg = 0x1e5304;
-		patch_num_reg = 0x1e5308;
+	if (adap_test) {
+		adap_patch_cnt = sizeof(adaptivity_patch_tbl_8800d80)/sizeof(u32)/2;
 	}
 
+	aic_patch_addr = rd_patch_addr + 8;
+
 	ret = rwnx_send_dbg_mem_read_req(sdiodev, rd_patch_addr, &rd_patch_addr_cfm);
 	if (ret) {
 		printk("patch rd fail\n");
@@ -117,31 +112,43 @@ int aicwifi_patch_config_8800d80(struct aic_sdio_dev *sdiodev)
 
 	config_base = rd_patch_addr_cfm.memdata;
 
-	ret = rwnx_send_dbg_mem_write_req(sdiodev, patch_addr_reg, patch_addr);
+	ret = rwnx_send_dbg_mem_read_req(sdiodev, aic_patch_addr, &rd_patch_addr_cfm);
+	if (ret) {
+		printk("patch str rd fail\n");
+		return ret;
+	}
+	aic_patch_str_base = rd_patch_addr_cfm.memdata;
+
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(magic_num), AIC_PATCH_MAGIG_NUM);
 	if (ret) {
-		printk("0x%x write fail\n", patch_addr_reg);
+		printk("0x%x write fail\n", AIC_PATCH_ADDR(magic_num));
 		return ret;
 	}
 
-	if(adap_test){
-		printk("%s for adaptivity test \r\n", __func__);
-		adap_patch_num = sizeof(adaptivity_patch_tbl_8800d80)/4;
-		ret = rwnx_send_dbg_mem_write_req(sdiodev, patch_num_reg, patch_num + adap_patch_num);
-	}else{
-		ret = rwnx_send_dbg_mem_write_req(sdiodev, patch_num_reg, patch_num);
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(magic_num_2), AIC_PATCH_MAGIG_NUM_2);
+	if (ret) {
+		printk("0x%x write fail\n", AIC_PATCH_ADDR(magic_num_2));
+		return ret;
 	}
+
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(pair_start), patch_addr);
 	if (ret) {
-		printk("0x%x write fail\n", patch_num_reg);
+		printk("0x%x write fail\n", AIC_PATCH_ADDR(pair_start));
 		return ret;
 	}
 
-	for (cnt = 0; cnt < patch_num/2; cnt += 1) {
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(pair_count), patch_cnt + adap_patch_cnt);
+	if (ret) {
+		printk("0x%x write fail\n", AIC_PATCH_ADDR(pair_count));
+		return ret;
+	}
+
+	for (cnt = 0; cnt < patch_cnt; cnt++) {
 		ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*cnt, patch_tbl_8800d80[cnt][0]+config_base);
 		if (ret) {
 			printk("%x write fail\n", start_addr+8*cnt);
 			return ret;
 		}
-
 		ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*cnt+4, patch_tbl_8800d80[cnt][1]);
 		if (ret) {
 			printk("%x write fail\n", start_addr+8*cnt+4);
@@ -149,21 +156,44 @@ int aicwifi_patch_config_8800d80(struct aic_sdio_dev *sdiodev)
 		}
 	}
 
-	tmp_cnt = cnt;
-	
-	if(adap_test){
-		for(cnt = 0; cnt < adap_patch_num/2; cnt+=1)
-		{
-			if((ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*(cnt+tmp_cnt), adaptivity_patch_tbl_8800d80[cnt][0]+config_base))) {
+	if (adap_test){
+		int tmp_cnt = patch_cnt + adap_patch_cnt;
+		for (cnt = patch_cnt; cnt < tmp_cnt; cnt++) {
+			int tbl_idx = cnt - patch_cnt;
+			ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*cnt, adaptivity_patch_tbl_8800d80[tbl_idx][0]+config_base);
+			if(ret) {
 				printk("%x write fail\n", start_addr+8*cnt);
+				return ret;
 			}
-		
-			if((ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*(cnt+tmp_cnt)+4, adaptivity_patch_tbl_8800d80[cnt][1]))) {
+			ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*cnt+4, adaptivity_patch_tbl_8800d80[tbl_idx][1]);
+			if(ret) {
 				printk("%x write fail\n", start_addr+8*cnt+4);
+				return ret;
 			}
 		}
 	}
 
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(block_size[0]), 0);
+	if (ret) {
+		printk("block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[0]), ret);
+		return ret;
+	}
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(block_size[1]), 0);
+	if (ret) {
+		printk("block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[1]), ret);
+		return ret;
+	}
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(block_size[2]), 0);
+	if (ret) {
+		printk("block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[2]), ret);
+		return ret;
+	}
+	ret = rwnx_send_dbg_mem_write_req(sdiodev, AIC_PATCH_ADDR(block_size[3]), 0);
+	if (ret) {
+		printk("block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[3]), ret);
+		return ret;
+	}
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.h
old mode 100755
new mode 100644
index 4124d62b6..209565826
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.h
@@ -2,7 +2,7 @@
 #define _AIC8800D80_COMPAT_H_
 
 #include "aicsdio.h"
-typedef u32 (*array2_tbl_t)[2];
+/*typedef u32 (*array2_tbl_t)[2];
 
 typedef uint8_t u8_l;
 typedef int8_t s8_l;
@@ -11,7 +11,7 @@ typedef uint16_t u16_l;
 typedef int16_t s16_l;
 typedef uint32_t u32_l;
 typedef int32_t s32_l;
-typedef uint64_t u64_l;
+typedef uint64_t u64_l;*/
 
 int aicbsp_system_config_8800d80(struct aic_sdio_dev *sdiodev);
 int aicwifi_sys_config_8800d80(struct aic_sdio_dev *sdiodev);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
old mode 100755
new mode 100644
index 836a62dfe..4ef066dde
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
@@ -1,4 +1,4 @@
-
+#include <linux/version.h>
 #include "aic8800dc_compat.h"
 #include "aic_bsp_driver.h"
 
@@ -25,6 +25,15 @@ u32 syscfg_tbl_8800dc_sdio_u02[][2] = {
     {0x40030084, 0x0011E800},
     {0x40030080, 0x00000001},
     {0x4010001C, 0x00000000},
+#ifdef CONFIG_OOB
+    {0x40504044, 0x2},//oob_enable
+    {0x40500060, 0x03020700},
+    {0x40500040, 0},
+    {0x40100030, 1},
+    {0x40241020, 1},
+    {0x402400f0, 0x340022},
+#endif //CONFIG_OOB
+
 };
 
 u32 syscfg_tbl_masked_8800dc[][3] = {
@@ -35,6 +44,7 @@ u32 syscfg_tbl_masked_8800dc[][3] = {
     {0x70002118, ((0x7 << 4) | (0x1 << 7)), ((0x2 << 4) | (0x1 << 7))},
     {0x70002104, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
     {0x7000210C, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x70002170, (0xF << 0), (0x1 << 0)},
     {0x70002190, (0x3F << 0), (24 << 0)},
     {0x700021CC, ((0x7 << 4) | (0x1 << 7)), ((0x0 << 4) | (0x0 << 7))},
     {0x700010A0, (0x1 << 11), (0x1 << 11)},
@@ -44,11 +54,58 @@ u32 syscfg_tbl_masked_8800dc[][3] = {
     {0x700021D0, ((0x1 << 5) | (0x1 << 6)), ((0x1 << 5) | (0x1 << 6))},
     {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
                  ((0x1 << 0) | (0x1 << 20) | (0x0 << 22))},
+    {0x70001028, (0xf << 2), (0x1 << 2)},
+    #else
+    {0x7000216C, (0x3 << 2), (0x1 << 2)}, // pmic_pmu_init
+    {0x700021BC, (0x3 << 2), (0x1 << 2)},
+    {0x70002118, ((0x7 << 4) | (0x1 << 7)), ((0x2 << 4) | (0x1 << 7))},
+    {0x70002104, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x7000210C, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x70002170, (0xF << 0), (0x1 << 0)},
+    {0x70002190, (0x3F << 0), (24 << 0)},
+    {0x700021CC, ((0x7 << 4) | (0x1 << 7)), ((0x0 << 4) | (0x0 << 7))},
+    {0x700010A0, (0x1 << 11), (0x1 << 11)},
+    {0x70001034, ((0x1 << 20) | (0x7 << 26)), ((0x0 << 20) | (0x2 << 26))},
+    {0x70001038, (0x1 << 8), (0x1 << 8)},
+    {0x70001094, (0x3 << 2), (0x0 << 2)},
+    {0x700021D0, ((0x1 << 5) | (0x1 << 6)), ((0x1 << 5) | (0x1 << 6))},
+    {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
+                 ((0x0 << 0) | (0x1 << 20) | (0x0 << 22))},
+    {0x70001028, (0xf << 2), (0x1 << 2)},
     #endif
     //#endif /* CONFIG_PMIC_SETTING */
     {0x00000000, 0x00000000, 0x00000000}, // last one
 };
 
+u32 syscfg_tbl_masked_8800dc_h[][3] = {
+    {0x7000216C, ((0x3 << 2) | (0x3 << 4)), ((0x2 << 2) | (0x2 << 4))}, // pmic_pmu_init
+    {0x70002138, (0xFF << 0), (0xFF << 0)},
+    {0x7000213C, (0xFF << 0), (0xFF << 0)},
+    {0x70002144, (0xFF << 0), (0xFF << 0)},
+    {0x700021BC, (0x3 << 2), (0x1 << 2)},
+    {0x70002118, ((0x7 << 4) | (0x1 << 7)), ((0x2 << 4) | (0x1 << 7))},
+    {0x70002104, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x7000210C, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x70002170, (0xF << 0), (0x1 << 0)},
+    {0x70002190, (0x3F << 0), (24 << 0)},
+    {0x700021CC, ((0x7 << 4) | (0x1 << 7)), ((0x0 << 4) | (0x0 << 7))},
+    {0x700010A0, (0x1 << 11), (0x1 << 11)},
+    //{0x70001034, ((0x1 << 20) | (0x7 << 26)), ((0x0 << 20) | (0x2 << 26))},
+    {0x70001038, (0x1 << 8), (0x1 << 8)},
+    {0x70001094, (0x3 << 2), (0x0 << 2)},
+    {0x700021D0, ((0x1 << 5) | (0x1 << 6)), ((0x1 << 5) | (0x1 << 6))},
+    #if defined(CONFIG_VRF_DCDC_MODE)
+    {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
+                 ((0x1 << 0) | (0x1 << 20) | (0x0 << 22))},
+    #else
+    {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
+                 ((0x0 << 0) | (0x1 << 20) | (0x0 << 22))},
+    #endif
+    {0x70001028, (0xf << 2), (0x1 << 2)},
+
+    {0x00000000, 0x00000000, 0x00000000}, // last one
+};
+
 u32 syscfg_tbl_masked_8800dc_u01[][3] = {
     //#ifdef CONFIG_PMIC_SETTING
     {0x70001000, (0x1 << 16), (0x1 << 16)}, // for low temperature
@@ -64,13 +121,17 @@ u32 patch_tbl_wifisetting_8800dc_u01[][2] =
 
 u32 patch_tbl_wifisetting_8800dc_u02[][2] =
 {
+#if defined(CONFIG_SDIO_PWRCTRL)
+    {0x0124,0x01011E01}
+#else
 	{0x0124,0x01001E01}
+#endif
 };
 
 
 
 uint32_t ldpc_cfg_ram[] = {
-    #ifdef CONFIG_FPGA_VERIFICATION
+#if 0//def CONFIG_FPGA_VERIFICATION
     0x00363638,
     0x1DF8F834,
     0x1DF8F834,
@@ -406,7 +467,7 @@ uint32_t ldpc_cfg_ram[] = {
     0x0213130F,
     0x02131308,
     0x02131308
-    #else
+#else
     0x00767679,
     0x1DF8F870,
     0x1DF8F870,
@@ -742,7 +803,7 @@ uint32_t ldpc_cfg_ram[] = {
     0x084C4C2C,
     0x084C4C19,
     0x084C4C19
-    #endif
+#endif
 };
 
 uint32_t agc_cfg_ram[] = {
@@ -1262,7 +1323,7 @@ uint32_t agc_cfg_ram[] = {
 
 
 uint32_t txgain_map[96] =  {
-    #ifdef CONFIG_FPGA_VERIFICATION
+#ifdef CONFIG_FPGA_VERIFICATION
     0x20c0c971,
     0x20c0c980,
     0x20c0c992,
@@ -1359,55 +1420,57 @@ uint32_t txgain_map[96] =  {
     0x20c0cba8,
     0x20c0cbbb,
     0x20c0cbd2,
-    #else
-    0x00ffc772,
-    0x00ffc780,
-    0x00ffc872,
-    0x00ffc880,
-    0x00ffc970,
-    0x00ffc980,
-    0x00ffc990,
-    0x00ffca80,
-    0x00ffca9a,
-    0x00ffcb90,
-    0x00ffcc95,
-    0x00ffce80,
-    0x00ffcf80,
-    0x00ffcf80,
-    0x00ffcf80,
-    0x00ffcf80,
-    0x00ffc05b,
-    0x00ffc066,
-    0x00ffc070,
-    0x00ffc080,
-    0x00ffc175,
-    0x00ffc185,
-    0x00ffc272,
-    0x00ffc280,
-    0x00ffc290,
-    0x00ffc380,
-    0x00ffc472,
-    0x00ffc483,
-    0x00ffc572,
-    0x00ffc580,
-    0x00ffc590,
-    0x00ffc680,
+#else
+    //11b
+    0x00ffd780,
+    0x00ffd872,
+    0x00ffd880,
+    0x00ffd972,
+    0x00ffd980,
+    0x00ffda75,
+    0x00ffda86,
+    0x00ffdb77,
+    0x00ffdb86,
+    0x00ffdc78,
+    0x00ffdc89,
+    0x00ffdd79,
+    0x00ffdd89,
+    0x00ffde83,
+    0x00ffdf79,
+    0x00ffdf8b,
+    0x00ffd072,
+    0x00ffd072,
+    0x00ffd080,
+    0x00ffd172,
+    0x00ffd180,
+    0x00ffd272,
+    0x00ffd280,
+    0x00ffd36d,
+    0x00ffd379,
+    0x00ffd46d,
+    0x00ffd479,
+    0x00ffd572,
+    0x00ffd580,
+    0x00ffd672,
+    0x00ffd680,
+    0x00ffd772,
+    //high
     0x00ffc87d,
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
     0x00ffca7d,
-    0x00ffca8d,
-    0x00ffcb7a,
-    0x00ffcb8a,
-    0x00ffcc7d,
-    0x00ffcc8d,
-    0x00ffcd79,
-    0x00ffcd89,
-    0x00ffce7d,
-    0x00ffce8d,
-    0x00ffcf80,
-    0x00ffcf99,
+    0x00ffca88,
+    0x00ffcc5e,
+    0x00ffcc69,
+    0x00ffcc78,
+    0x00ffcc85,
+    0x00ffcd70,
+    0x00ffcd80,
+    0x00ffce70,
+    0x00ffce80,
+    0x00ffcf7d,
+    0x00ffcf90,
     0x00ffc080,
     0x00ffc090,
     0x00ffc180,
@@ -1415,31 +1478,32 @@ uint32_t txgain_map[96] =  {
     0x00ffc27b,
     0x00ffc28b,
     0x00ffc37b,
-    0x00ffc38b,
-    0x00ffc480,
-    0x00ffc490,
+    0x00ffc390,
+    0x00ffc485,
+    0x00ffc495,
     0x00ffc579,
     0x00ffc589,
     0x00ffc679,
     0x00ffc689,
     0x00ffc780,
     0x00ffc790,
+    //low
     0x00ffc87d,
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
     0x00ffca7d,
-    0x00ffca8d,
-    0x00ffcb7a,
-    0x00ffcb8a,
-    0x00ffcc7d,
-    0x00ffcc8d,
-    0x00ffcd79,
-    0x00ffcd89,
-    0x00ffce7d,
-    0x00ffce8d,
-    0x00ffcf80,
-    0x00ffcf99,
+    0x00ffca88,
+    0x00ffcc5e,
+    0x00ffcc69,
+    0x00ffcc78,
+    0x00ffcc85,
+    0x00ffcd70,
+    0x00ffcd80,
+    0x00ffce70,
+    0x00ffce80,
+    0x00ffce93,
+    0x00ffcf90,
     0x00ffc080,
     0x00ffc090,
     0x00ffc180,
@@ -1447,16 +1511,16 @@ uint32_t txgain_map[96] =  {
     0x00ffc27b,
     0x00ffc28b,
     0x00ffc37b,
-    0x00ffc38b,
-    0x00ffc480,
-    0x00ffc490,
+    0x00ffc390,
+    0x00ffc485,
+    0x00ffc495,
     0x00ffc579,
     0x00ffc589,
     0x00ffc679,
     0x00ffc689,
     0x00ffc780,
-    0x00ffc790
-    #endif
+    0x00ffc790,
+#endif
 };
 
 
@@ -1521,9 +1585,13 @@ u32 patch_tbl_rf_func[][2] =
     {0x00110bf0, 0x00180001},
 };
 
+#define CHIP_ID_H_MASK  0xC0
+#define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
+
 void system_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 {
     int syscfg_num;
+    array3_tbl_t p_syscfg_msk_tbl;
     int ret, cnt;
     const u32 mem_addr = 0x40500000;
 	u8 chip_id = 0;
@@ -1589,23 +1657,29 @@ void system_config_8800dc(struct aic_sdio_dev *rwnx_hw)
         }
     }
 
-	syscfg_num = sizeof(syscfg_tbl_masked_8800dc) / sizeof(u32) / 3;
+    if (IS_CHIP_ID_H()) {
+        syscfg_num = sizeof(syscfg_tbl_masked_8800dc_h) / sizeof(u32) / 3;
+        p_syscfg_msk_tbl = syscfg_tbl_masked_8800dc_h;
+    } else {
+        syscfg_num = sizeof(syscfg_tbl_masked_8800dc) / sizeof(u32) / 3;
+        p_syscfg_msk_tbl = syscfg_tbl_masked_8800dc;
+    }
 
 
     for (cnt = 0; cnt < syscfg_num; cnt++) {
-	    if (syscfg_tbl_masked_8800dc[cnt][0] == 0x00000000) {
+        if (p_syscfg_msk_tbl[cnt][0] == 0x00000000) {
             break;
-        } else if (syscfg_tbl_masked_8800dc[cnt][0] == 0x70001000) {
+        } else if (p_syscfg_msk_tbl[cnt][0] == 0x70001000) {
             if (chip_mcu_id == 0) {
-                syscfg_tbl_masked_8800dc[cnt][1] |= ((0x1 << 8) | (0x1 << 15)); // mask
-                syscfg_tbl_masked_8800dc[cnt][2] |= ((0x1 << 8) | (0x1 << 15));
+                p_syscfg_msk_tbl[cnt][1] |= ((0x1 << 8) | (0x1 << 15)); // mask
+                p_syscfg_msk_tbl[cnt][2] |= ((0x1 << 8) | (0x1 << 15));
             }
         }
 
         ret = rwnx_send_dbg_mem_mask_write_req(rwnx_hw,
-            syscfg_tbl_masked_8800dc[cnt][0], syscfg_tbl_masked_8800dc[cnt][1], syscfg_tbl_masked_8800dc[cnt][2]);
+            p_syscfg_msk_tbl[cnt][0], p_syscfg_msk_tbl[cnt][1], p_syscfg_msk_tbl[cnt][2]);
         if (ret) {
-			AICWFDBG(LOGERROR, "%x mask write fail: %d\n", syscfg_tbl_masked_8800dc[cnt][0], ret);
+            AICWFDBG(LOGERROR, "%x mask write fail: %d\n", p_syscfg_msk_tbl[cnt][0], ret);
             return;
         }
     }
@@ -1679,7 +1753,7 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 	        }
 	        jump_tbl_addr = cfm.memdata;
 		}
-		
+
         if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 8, &cfm))) {
             AICWFDBG(LOGERROR, "setting base[0x%x] rd fail: %d\n", cfg_base + 8, ret);
         }
@@ -1762,7 +1836,7 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 			       printk("patch_tbl upload fail: err:%d\r\n", ret);
 			}
 		}
-		
+
         #endif
     } else {
         if (chip_sub_id == 0) {
@@ -1776,5 +1850,144 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
     }
 }
 
+int aicwf_misc_ram_init_8800dc(struct aic_sdio_dev *sdiodev)
+{
+    int ret = 0;
+    const uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t misc_ram_size = 12;
+    int i;
+    // init misc ram
+    ret = rwnx_send_dbg_mem_read_req(sdiodev, cfg_base + 0x14, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGERROR, "misc_ram_addr=%x\n", misc_ram_addr);
+    for (i = 0; i < (misc_ram_size / 4); i++) {
+        ret = rwnx_send_dbg_mem_write_req(sdiodev, misc_ram_addr + i * 4, 0);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] wr fail: %d\n",  misc_ram_addr + i * 4, ret);
+            return ret;
+        }
+    }
+    return ret;
+}
+
+#ifdef CONFIG_DPD
+int aicwf_dpd_calib_8800dc(struct aic_sdio_dev *sdiodev, uint32_t *dpd_res)
+{
+    int ret = 0;
+    uint32_t fw_addr, boot_type;
+
+	printk("%s\n", __func__);
+
+    ret = aicwf_plat_calib_load_8800dc(sdiodev);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    /* fw start */
+    fw_addr = 0x00130009;
+    boot_type = HOST_START_APP_FNCALL;
+    AICWFDBG(LOGINFO, "Start app: %08x, %d\n", fw_addr, boot_type);
+    ret = rwnx_send_dbg_start_app_req(sdiodev, fw_addr, boot_type, NULL);
+    if (ret) {
+        AICWFDBG(LOGINFO, "start app fail: %d\n", ret);
+        return ret;
+    }
+    { // read dpd res
+        const uint32_t cfg_base = 0x10164;
+        struct dbg_mem_read_cfm cfm;
+        uint32_t misc_ram_addr;
+        uint32_t misc_ram_size = DPD_RESULT_SIZE_8800DC;
+        int i;
+        ret = rwnx_send_dbg_mem_read_req(sdiodev, cfg_base + 0x14, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+            return ret;
+        }
+        misc_ram_addr = cfm.memdata;
+        for (i = 0; i < (misc_ram_size / 4); i++) {
+            ret = rwnx_send_dbg_mem_read_req(sdiodev, misc_ram_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n",  misc_ram_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res[i] = cfm.memdata;
+        }
+    }
+    return ret;
+}
+
+int aicwf_dpd_result_load_8800dc(struct aic_sdio_dev *sdiodev)
+{
+	printk("%s\n", __func__);
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+	if (testmode == 1) {
+		cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+	}
+    if ((ret = rwnx_send_dbg_mem_read_req(sdiodev, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    ret = rwnx_plat_bin_fw_upload_android(sdiodev, misc_ram_addr, FW_DPDRESULT_NAME_8800DC);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    return ret;
+}
+
+int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
+{
+	printk("%s\n", __func__);
+    int sum = 0, len = 0;
+    char *path = NULL;
+    struct file *fp = NULL;
+    loff_t pos = 0;
+    mm_segment_t fs;
+
+    path = __getname();
+    if (!path) {
+        AICWFDBG(LOGINFO, "get path fail\n");
+        return -1;
+    }
+
+    len = snprintf(path, FW_PATH_MAX_LEN, "%s/%s", AICBSP_FW_PATH, FW_DPDRESULT_NAME_8800DC);
+    printk("%s\n", path);
+
+    fp = filp_open(path, O_RDWR | O_CREAT, 0644);
+    if (IS_ERR(fp)) {
+        AICWFDBG(LOGINFO, "fp open fial\n");
+		__putname(path);
+        fp = NULL;
+        return -1;
+    }
+
+    fs = get_fs();
+    set_fs(KERNEL_DS);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+    sum = kernel_write(fp, buf, buf_len, &pos);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+    sum = kernel_write(fp, (char *)buf, buf_len, pos);
+#else
+    sum = vfs_write(fp, (char *)buf, buf_len, &pos);
+#endif
+
+    set_fs(fs);
+    __putname(path);
+    filp_close(fp, NULL);
+	fp = NULL;
+
+    return 0;
+}
+#endif
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
old mode 100755
new mode 100644
index 138e204e4..09f303bc0
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
@@ -3,6 +3,7 @@
 
 #include "aicsdio.h"
 typedef u32 (*array2_tbl_t)[2];
+typedef u32 (*array3_tbl_t)[3];
 
 typedef uint8_t u8_l;
 typedef int8_t s8_l;
@@ -15,10 +16,18 @@ typedef uint64_t u64_l;
 
 extern u8 chip_sub_id;
 extern u8 chip_mcu_id;
+#define DPD_RESULT_SIZE_8800DC 1880
+#define FW_PATH_MAX_LEN 200
 
 void aicwf_patch_config_8800dc(struct          aic_sdio_dev *rwnx_hw);
 void system_config_8800dc(struct aic_sdio_dev *rwnx_hw);
+int aicwf_misc_ram_init_8800dc(struct aic_sdio_dev *sdiodev);
 
+#ifdef CONFIG_DPD
+int aicwf_dpd_calib_8800dc(struct aic_sdio_dev *sdiodev, uint32_t *dpd_res);
+int aicwf_dpd_result_load_8800dc(struct aic_sdio_dev *sdiodev);
+int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
+#endif
 
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
old mode 100755
new mode 100644
index 82c4436a6..4b02d68ce
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
@@ -525,20 +525,20 @@ int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device)
 	void *buffer = NULL;
 	char *path = NULL;
 	struct file *fp = NULL;
-	int size = 0, len = 0, i = 0;
+	int size = 0, len = 0;// i = 0;
 	ssize_t rdlen = 0;
-	u32 *src = NULL, *dst = NULL;
+	//u32 *src = NULL, *dst = NULL;
 	MD5_CTX md5;
 	unsigned char decrypt[16];
 
 	#ifdef CONFIG_FIRMWARE_ARRAY
 		size = aicwf_get_firmware_array((char*)name, fw_buf);
 		printk("%s size:%d \r\n", __func__, size);
-		MD5Init(&md5);         		
+		MD5Init(&md5);
 		MD5Update(&md5, (unsigned char *)*fw_buf, size);
 		MD5Final(&md5, decrypt);
 		printk(MD5PINRT, MD5(decrypt));
-		
+
 		return size;
 	#endif
 
@@ -585,7 +585,7 @@ int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device)
 
 	/* start to read from firmware file */
 	buffer = vmalloc(size);
-	
+
 	if (!buffer) {
 		*fw_buf = NULL;
 		__putname(path);
@@ -595,7 +595,7 @@ int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device)
 	}else{
 		memset(buffer, 0, size);
 	}
-	
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
 	rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
 #else
@@ -616,10 +616,11 @@ int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device)
 		fp->f_pos += rdlen;
 	}
 
+#if 0
 	/*start to transform the data format*/
 	src = (u32 *)buffer;
 	dst = (u32 *)vmalloc(size);
-	
+
 	if (!dst) {
 		*fw_buf = NULL;
 		__putname(path);
@@ -635,16 +636,17 @@ int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device)
 	for (i = 0; i < (size/4); i++) {
 		dst[i] = src[i];
 	}
+#endif
 
 	__putname(path);
 	filp_close(fp, NULL);
 	fp = NULL;
-	vfree(buffer);
-	buffer = NULL;
-	*fw_buf = dst;
+	//vfree(buffer);
+	//buffer = NULL;
+	*fw_buf = (u32*)buffer;
 
-	MD5Init(&md5);         		
-	MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Init(&md5);
+	MD5Update(&md5, (unsigned char *)buffer, size);
 	MD5Final(&md5, decrypt);
 
 	printk(MD5PINRT, MD5(decrypt));
@@ -721,45 +723,197 @@ extern char aic_fw_path[200];
 extern int testmode;
 int aicwf_plat_patch_load_8800dc(struct aic_sdio_dev *sdiodev)
 {
-	int ret = 0;
+    int ret = 0;
+    #if !defined(CONFIG_FPGA_VERIFICATION)
+    if (chip_sub_id == 0) {
+        printk("u01 is loaing ###############\n");
+        ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
+    } else if (chip_sub_id == 1) {
+        printk("u02 is loaing ###############\n");
+        ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
+    } else {
+        printk("unsupported id: %d\n", chip_sub_id);
+    }
+    #endif
+    return ret;
+}
 
-	if (testmode == 0) {
-#if !defined(CONFIG_FPGA_VERIFICATION)
-        if (chip_sub_id == 0) {
-			printk("u01 is loaing ###############\n");
-			ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
-		} else if (chip_sub_id == 1) {
-			printk("u02 is loaing ###############\n");
-			ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
-		} else {
-			printk("unsupported id: %d\n", chip_sub_id);
-		}
-#endif
-	} else {
-		if (chip_sub_id == 0) {
-			ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_PATCH_ADDR, RWNX_MAC_RF_PATCH_NAME_8800DC);
-		}
-		if (!ret) {
-			ret = rwnx_plat_bin_fw_upload_android(sdiodev, RAM_LMAC_FW_ADDR, RWNX_MAC_FW_RF_BASE_NAME_8800DC);
-		}
-	}
+int aicwf_plat_rftest_load_8800dc(struct aic_sdio_dev *sdiodev)
+{
+    int ret = 0;
+    ret = rwnx_plat_bin_fw_upload_android(sdiodev, RAM_LMAC_FW_ADDR, RWNX_MAC_FW_RF_BASE_NAME_8800DC);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+        return ret;
+    }
+    return ret;
+}
 
-	return ret;
+#ifdef CONFIG_DPD
+int aicwf_plat_calib_load_8800dc(struct aic_sdio_dev *sdiodev)
+{
+    int ret = 0;
+    if (chip_sub_id == 1) {
+        ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_U02);
+        if (ret) {
+            AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+            return ret;
+        }
+    }
+    return ret;
+}
+
+int is_file_exist(char* name)
+{
+    char *path = NULL;
+    struct file *fp = NULL;
+    int len;
+
+    path = __getname();
+    if (!path) {
+        AICWFDBG(LOGINFO, "%s getname fail\n", __func__);
+        return -1;
+    }
+
+    len = snprintf(path, FW_PATH_MAX_LEN, "%s/%s", AICBSP_FW_PATH, name);
+
+    fp = filp_open(path, O_RDONLY, 0);
+    if (IS_ERR(fp)) {
+        __putname(path);
+        fp = NULL;
+        return 0;
+    } else {
+        __putname(path);
+        filp_close(fp, NULL);
+		fp = NULL;
+        return 1;
+    }
 }
 
+EXPORT_SYMBOL(is_file_exist);
+#endif
+
 static int rwnx_plat_patch_load(struct aic_sdio_dev *sdiodev)
 {
 	int ret = 0;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-	if(sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
-		sdiodev->chipid == PRODUCT_ID_AIC8800DW){
-		printk("rwnx_plat_patch_loading\n");
-		ret = aicwf_plat_patch_load_8800dc(sdiodev);
-	}
+    if (sdiodev->chipid == PRODUCT_ID_AIC8800DC || sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
+        AICWFDBG(LOGINFO, "testmode=%d\n", testmode);
+        if (chip_sub_id == 0) {
+            if (testmode == FW_NORMAL_MODE) {
+                AICWFDBG(LOGINFO, "rwnx_plat_patch_loading\n");
+                ret = aicwf_plat_patch_load_8800dc(sdiodev);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                    return ret;
+                }
+            } else if (testmode == FW_RFTEST_MODE) {
+                ret = aicwf_plat_rftest_load_8800dc(sdiodev);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+        } else if (chip_sub_id == 1) {
+            if (testmode == FW_NORMAL_MODE) {
+                AICWFDBG(LOGINFO, "rwnx_plat_patch_loading\n");
+                ret = aicwf_plat_patch_load_8800dc(sdiodev);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                    return ret;
+                }
+                #ifdef CONFIG_DPD
+                #ifdef CONFIG_FORCE_DPD_CALIB
+                if (1) {
+                    uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(sdiodev, &dpd_res[0]);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #else
+                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
+                    AICWFDBG(LOGINFO, "dpd bin load\n");
+                    ret = aicwf_dpd_result_load_8800dc(sdiodev);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif
+                else
+                #endif
+                {
+                    aicwf_misc_ram_init_8800dc(sdiodev);
+                }
+            } else if (testmode == FW_RFTEST_MODE) {
+                #ifdef CONFIG_DPD
+                #ifdef CONFIG_FORCE_DPD_CALIB
+                if (1) {
+                    uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(sdiodev);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(sdiodev, &dpd_res[0]);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif
+                #endif
+                ret = aicwf_plat_rftest_load_8800dc(sdiodev);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+                    return ret;
+                }
+            } else if (testmode == FW_DPDCALIB_MODE) {
+                #ifdef CONFIG_DPD
+                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 0) {
+                    uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(sdiodev);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(sdiodev, &dpd_res[0]);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif
+                return 1; // exit calib mode
+            }
+        }
+    }
 
-	return ret;
+    return ret;
 }
 
 int rwnx_plat_bin_fw_upload_android(struct aic_sdio_dev *sdiodev, u32 fw_addr,
@@ -896,7 +1050,7 @@ int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_
         patch_info->info_len = head_t->len;
         if(patch_info->info_len == 0)
             return 0;
-        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t));
+        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
     }
     return 0;
 }
@@ -943,7 +1097,7 @@ int aicbt_patch_trap_data_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_
         if (aicbsp_info.chip_rev == CHIP_REV_U01) {
 		    patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80;
 		    patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80;
-        } else if (aicbsp_info.chip_rev == CHIP_REV_U02) {
+        } else if (aicbsp_info.chip_rev == CHIP_REV_U02 || aicbsp_info.chip_rev == CHIP_REV_U03) {
             patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80_U02;
 		    patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80_U02;
         }
@@ -990,14 +1144,15 @@ int aicbt_patch_table_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_tabl
     }
 	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80){
         if (sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
-            aicbt_info.btmode = 5;
+            //aicbt_info.btmode = AICBT_BTMODE_BT_ONLY_COANT;
+            aicbt_info.txpwr_lvl = AICBT_TXPWR_LVL_8800d80;
         }
 		for (p = head; p != NULL; p = p->next) {
 			data = p->data;
 			if (AICBT_PT_BTMODE == p->type) {
 				*(data + 1)  = aicbsp_info.hwinfo < 0;
 				*(data + 3)  = aicbsp_info.hwinfo;
-				*(data + 5)  = aicbsp_info.cpmode;
+				*(data + 5)  = 0;//aicbsp_info.cpmode;
 
 				*(data + 7)  = aicbt_info.btmode;
 				*(data + 9)  = aicbt_info.btport;
@@ -1005,7 +1160,7 @@ int aicbt_patch_table_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_tabl
 				*(data + 13) = aicbt_info.uart_flowctrl;
 				*(data + 15) = aicbt_info.lpm_enable;
 				*(data + 17) = aicbt_info.txpwr_lvl;
-                
+
                 		printk("%s bt btmode:%d \r\n", __func__, aicbt_info.btmode);
 				printk("%s bt uart_baud:%d \r\n", __func__, aicbt_info.uart_baud);
 				printk("%s bt uart_flowctrl:%d \r\n", __func__, aicbt_info.uart_flowctrl);
@@ -1262,14 +1417,14 @@ static int aicwifi_patch_config(struct aic_sdio_dev *sdiodev)
 	}
 
 	tmp_cnt = cnt;
-	
+
 	if(adap_test){
 		for(cnt = 0; cnt < adap_patch_num/2; cnt+=1)
 		{
 			if((ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*(cnt+tmp_cnt), adaptivity_patch_tbl[cnt][0]+config_base))) {
 				printk("%x write fail\n", start_addr+8*cnt);
 			}
-		
+
 			if((ret = rwnx_send_dbg_mem_write_req(sdiodev, start_addr+8*(cnt+tmp_cnt)+4, adaptivity_patch_tbl[cnt][1]))) {
 				printk("%x write fail\n", start_addr+8*cnt+4);
 			}
@@ -1281,6 +1436,7 @@ static int aicwifi_patch_config(struct aic_sdio_dev *sdiodev)
 
 int aicwifi_init(struct aic_sdio_dev *sdiodev)
 {
+	int ret = 0;
 	if(sdiodev->chipid == PRODUCT_ID_AIC8801){
 		if (rwnx_plat_bin_fw_upload_android(sdiodev, RAM_FMAC_FW_ADDR, aicbsp_firmware_list[aicbsp_info.cpmode].wl_fw)) {
 			printk("download wifi fw fail\n");
@@ -1307,7 +1463,11 @@ int aicwifi_init(struct aic_sdio_dev *sdiodev)
 		system_config_8800dc(sdiodev);
 		printk("############ system_config_8800dc done\n");
 
-		rwnx_plat_patch_load(sdiodev);
+		ret = rwnx_plat_patch_load(sdiodev);
+		if (ret) {
+			printk("patch load return %d\n", ret);
+			return ret;
+		}
 		printk("############ rwnx_plat_patch_load done\n");
 
 		//rwnx_plat_userconfig_load(sdiodev);
@@ -1398,13 +1558,14 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev)
 	u32 mem_addr;
 	struct dbg_mem_read_cfm rd_mem_addr_cfm;
 	u32 btenable = 0;
-	
+	int ret = 0;
+
 	mem_addr = 0x40500000;
 
 	testmode = aicbsp_info.cpmode;
 
 	if(sdiodev->chipid == PRODUCT_ID_AIC8801){
-		
+
 		if (rwnx_send_dbg_mem_read_req(sdiodev, mem_addr, &rd_mem_addr_cfm))
 			return -1;
 
@@ -1447,12 +1608,12 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev)
 		}
 		if(aicbsp_info.chip_rev == CHIP_REV_U01){
 			aicbsp_firmware_list = fw_8800dc_u01;
-		}else if(aicbsp_info.chip_rev == CHIP_REV_U02){
+		}else{
 			aicbsp_firmware_list = fw_8800dc_u02;
 		}
 	}
     else if(sdiodev->chipid == PRODUCT_ID_AIC8800D80){
-		
+
 		if (rwnx_send_dbg_mem_read_req(sdiodev, mem_addr, &rd_mem_addr_cfm))
 			return -1;
 
@@ -1461,30 +1622,33 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev)
 
 		if (aicbsp_info.chip_rev == CHIP_REV_U01)
             aicbsp_firmware_list = fw_8800d80_u01;
-        if (aicbsp_info.chip_rev == CHIP_REV_U02)
+        if (aicbsp_info.chip_rev == CHIP_REV_U02 || aicbsp_info.chip_rev == CHIP_REV_U03)
             aicbsp_firmware_list = fw_8800d80_u02;
         if (aicbsp_system_config_8800d80(sdiodev))
             return -1;
 	}
-	
+
 	AICWFDBG(LOGINFO, "aicbsp: %s, chip rev: %d\n", __func__, aicbsp_info.chip_rev);
 
 	#ifndef CONFIG_MCU_MESSAGE
-	if(btenable == 1){
-		if (aicbt_init(sdiodev))
-			return -1;
+	if (testmode != 4) {
+		if(btenable == 1){
+			if (aicbt_init(sdiodev))
+				return -1;
+		}
 	}
 	#endif
 
-	if (aicwifi_init(sdiodev))
-		return -1;
+	ret = aicwifi_init(sdiodev);
+	if (ret)
+		return ret;
 
 	return 0;
 }
 
 int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path)
 {
-	if (aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8801 || 
+	if (aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8801 ||
         aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800DW){
 	    feature->sdio_clock = FEATURE_SDIO_CLOCK;
@@ -1501,3 +1665,83 @@ int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(aicbsp_get_feature);
+
+#if AICBSP_RESV_MEM_SUPPORT
+static struct skb_buff_pool resv_skb[] = {
+	{AIC_RESV_MEM_TXDATA, 1536*64, "resv_mem_txdata", 0, NULL},
+};
+
+int aicbsp_resv_mem_init(void)
+{
+    int i = 0;
+	printk("%s \n",__func__);
+    for (i = 0; i < sizeof(resv_skb) / sizeof(resv_skb[0]); i++) {
+            resv_skb[i].skb = dev_alloc_skb(resv_skb[i].size);
+    }
+    return 0;
+}
+
+int aicbsp_resv_mem_deinit(void)
+{
+    int i = 0;
+	printk("%s \n",__func__);
+    for (i = 0; i < sizeof(resv_skb) / sizeof(resv_skb[0]); i++) {
+            if (resv_skb[i].used == 0 && resv_skb[i].skb)
+                    dev_kfree_skb(resv_skb[i].skb);
+    }
+    return 0;
+}
+
+struct sk_buff *aicbsp_resv_mem_alloc_skb(unsigned int length, uint32_t id)
+{
+    if (resv_skb[id].size < length) {
+            pr_err("aicbsp: %s, no enough mem\n", __func__);
+            goto fail;
+    }
+
+    if (resv_skb[id].used) {
+            pr_err("aicbsp: %s, mem in use\n", __func__);
+            goto fail;
+    }
+
+    if (resv_skb[id].skb == NULL) {
+            pr_err("aicbsp: %s, mem not initialazed\n", __func__);
+            resv_skb[id].skb = dev_alloc_skb(resv_skb[id].size);
+            if (resv_skb[id].skb == NULL) {
+                    pr_err("aicbsp: %s, mem reinitial still fail\n", __func__);
+                    goto fail;
+            }
+    }
+
+    printk("aicbsp: %s, alloc %s succuss, id: %d, size: %d\n", __func__,
+                    resv_skb[id].name, resv_skb[id].id, resv_skb[id].size);
+
+    resv_skb[id].used = 1;
+	return resv_skb[id].skb;
+
+fail:
+    return NULL;
+}
+EXPORT_SYMBOL_GPL(aicbsp_resv_mem_alloc_skb);
+
+void aicbsp_resv_mem_kfree_skb(struct sk_buff *skb, uint32_t id)
+{
+	resv_skb[id].used = 0;
+	printk("aicbsp: %s, free %s succuss, id: %d, size: %d\n", __func__,
+                    resv_skb[id].name, resv_skb[id].id, resv_skb[id].size);
+}
+EXPORT_SYMBOL_GPL(aicbsp_resv_mem_kfree_skb);
+
+#else
+
+int aicbsp_resv_mem_init(void)
+{
+	return 0;
+}
+
+int aicbsp_resv_mem_deinit(void)
+{
+	return 0;
+}
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
old mode 100755
new mode 100644
index b5897e265..6f010b1d3
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include "aic_bsp_export.h"
 
-#define RWNX_80211_CMD_TIMEOUT_MS    2000//500//300
+#define RWNX_80211_CMD_TIMEOUT_MS    3000//500//300
 
 #define RWNX_CMD_FLAG_NONBLOCK      BIT(0)
 #define RWNX_CMD_FLAG_REQ_CFM       BIT(1)
@@ -223,15 +223,15 @@ enum dbg_msg_tag {
 	DBG_BINDING_REQ,
 	DBG_BINDING_CFM,
 	DBG_BINDING_IND,
-	
+
 	DBG_CUSTOM_MSG_REQ,
 	DBG_CUSTOM_MSG_CFM,
 	DBG_CUSTOM_MSG_IND,
-	
+
 	DBG_GPIO_WRITE_REQ,
 	DBG_GPIO_WRITE_CFM,
 
-	
+
 	/// Max number of Debug messages
 	DBG_MAX,
 };
@@ -302,6 +302,12 @@ struct dbg_start_app_cfm {
 	u32 bootstatus;
 };
 
+int aicwf_plat_patch_load_8800dc(struct aic_sdio_dev *sdiodev);
+int aicwf_plat_rftest_load_8800dc(struct aic_sdio_dev *sdiodev);
+#ifdef CONFIG_DPD
+int aicwf_plat_calib_load_8800dc(struct aic_sdio_dev *sdiodev);
+#endif
+
 int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *device);
 int aicwf_patch_table_load(struct aic_sdio_dev *rwnx_hw, char *filename);
 
@@ -320,6 +326,11 @@ void rwnx_rx_handle_msg(struct aic_sdio_dev *sdiodev, struct ipc_e2a_msg *msg);
 int aicbsp_platform_init(struct aic_sdio_dev *sdiodev);
 void aicbsp_platform_deinit(struct aic_sdio_dev *sdiodev);
 int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev);
+#ifdef CONFIG_DPD
+int is_file_exist(char* name);
+#endif
+int aicbsp_resv_mem_init(void);
+int aicbsp_resv_mem_deinit(void);
 
 #define AICBSP_FW_PATH              CONFIG_AIC_FW_PATH
 #define AICBSP_FW_PATH_MAX          200
@@ -351,6 +362,14 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev);
 #define ROM_FMAC_FW_ADDR               0x00010000
 #define ROM_FMAC_PATCH_ADDR            0x00180000
 
+#define RWNX_MAC_CALIB_BASE_NAME_8800DC        "fmacfw_calib_8800dc"
+#define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
+
+#ifdef CONFIG_DPD
+#define ROM_FMAC_CALIB_ADDR            0x00130000
+#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_8800dc.bin"
+#endif
+
 #define RWNX_MAC_FW_RF_BASE_NAME_8800DC   "lmacfw_rf_8800dc.bin"
 
 #ifdef CONFIG_FOR_IPCOM
@@ -370,6 +389,15 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev);
 #define RWNX_MAC_RF_PATCH_NAME_8800DC RWNX_MAC_RF_PATCH_BASE_NAME_8800DC".bin"
 #define FW_USERCONFIG_NAME_8800DC         "aic_userconfig_8800dc.txt"
 
+enum {
+    FW_NORMAL_MODE          = 0,
+    FW_RFTEST_MODE          = 1,
+    FW_BLE_SCAN_WAKEUP_MODE = 2,
+    FW_M2D_OTA_MODE         = 3,
+    FW_DPDCALIB_MODE        = 4,
+    FW_BLE_SCAN_AD_FILTER_MODE = 5,
+};
+
 enum aicbt_patch_table_type {
 	AICBT_PT_INF  = 0x00,
 	AICBT_PT_TRAP = 0x1,
@@ -396,6 +424,7 @@ enum aicbt_btmode_type {
 	AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
 	AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
 	AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+	AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
 	AICBT_MODE_NULL = 0xFF,           // invalid value
 };
 
@@ -431,6 +460,7 @@ enum chip_rev {
 ///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
 #define AICBT_TXPWR_LVL            0x00006020
 #define AICBT_TXPWR_LVL_8800dc            0x00006f2f
+#define AICBT_TXPWR_LVL_8800d80           0x00006f2f
 
 #define AICBSP_HWINFO_DEFAULT       (-1)
 #define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
old mode 100755
new mode 100644
index ff5cd1d34..535f7bf0e
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
@@ -1,6 +1,8 @@
 #ifndef __AIC_BSP_EXPORT_H
 #define __AIC_BSP_EXPORT_H
 
+#define AICBSP_RESV_MEM_SUPPORT 0
+
 enum aicbsp_subsys {
 	AIC_BLUETOOTH,
 	AIC_WIFI,
@@ -11,6 +13,18 @@ enum aicbsp_pwr_state {
 	AIC_PWR_ON,
 };
 
+enum skb_buff_id {
+	AIC_RESV_MEM_TXDATA,
+};
+
+struct skb_buff_pool {
+	uint32_t id;
+	uint32_t size;
+	const char *name;
+	uint8_t used;
+	struct sk_buff *skb;
+};
+
 struct aicbsp_feature_t {
 	int      hwinfo;
 	uint32_t sdio_clock;
@@ -20,5 +34,7 @@ struct aicbsp_feature_t {
 
 int aicbsp_set_subsys(int, int);
 int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path);
+struct sk_buff *aicbsp_resv_mem_alloc_skb(unsigned int length, uint32_t id);
+void aicbsp_resv_mem_kfree_skb(struct sk_buff *skb, uint32_t id);
 
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
old mode 100755
new mode 100644
index feab672ed..9b7b11ee0
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
@@ -7,14 +7,15 @@
 #include <linux/platform_device.h>
 #include "aic_bsp_driver.h"
 #include "rwnx_version_gen.h"
+#include "aicwf_txq_prealloc.h"
+
 
 #define DRV_DESCRIPTION       "AIC BSP"
 #define DRV_COPYRIGHT         "Copyright(c) 2015-2020 AICSemi"
 #define DRV_AUTHOR            "AICSemi"
 #define DRV_VERS_MOD          "1.0"
 
-//int aicwf_dbg_level_bsp = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
-int aicwf_dbg_level_bsp = LOGERROR;
+int aicwf_dbg_level_bsp = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
 
 static struct platform_device *aicbsp_pdev;
 
@@ -110,7 +111,7 @@ const struct aicbsp_firmware fw_8800d80_u01[] = {
 		.bt_adid       = "fw_adid_8800d80.bin",
 		.bt_patch      = "fw_patch_8800d80.bin",
 		.bt_table      = "fw_patch_table_8800d80.bin",
-		.wl_fw         = "fmacfw_rf_8800d80.bin"
+		.wl_fw         = "lmacfw_rf_8800d80.bin"
 	},
 };
 
@@ -128,7 +129,7 @@ const struct aicbsp_firmware fw_8800d80_u02[] = {
 		.bt_adid       = "fw_adid_8800d80_u02.bin",
 		.bt_patch      = "fw_patch_8800d80_u02.bin",
 		.bt_table      = "fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "fmacfw_rf_8800d80_u02.bin"
+		.wl_fw         = "lmacfw_rf_8800d80_u02.bin"
 	},
 };
 
@@ -298,9 +299,10 @@ static int __init aicbsp_init(void)
 	int ret;
 	printk("%s\n", __func__);
 	printk("RELEASE_DATE:%s\r\n", RELEASE_DATE);
-	
+
 	aicbsp_info.cpmode = testmode;
-	
+
+	aicbsp_resv_mem_init();
 	ret = platform_driver_register(&aicbsp_driver);
 	if (ret) {
 		pr_err("register platform driver failed: %d\n", ret);
@@ -328,16 +330,23 @@ static int __init aicbsp_init(void)
 }
 
 void aicbsp_sdio_exit(void);
+extern struct aic_sdio_dev *aicbsp_sdiodev;
 
 static void __exit aicbsp_exit(void)
 {
 #ifdef CONFIG_PLATFORM_ROCKCHIP
-	aicbsp_sdio_exit();
+    if(aicbsp_sdiodev){
+    	aicbsp_sdio_exit();
+    }
 #endif
 	sysfs_remove_group(&(aicbsp_pdev->dev.kobj), &aicbsp_attribute_group);
 	platform_device_del(aicbsp_pdev);
 	platform_driver_unregister(&aicbsp_driver);
 	mutex_destroy(&aicbsp_power_lock);
+	aicbsp_resv_mem_deinit();
+#ifdef CONFIG_PREALLOC_TXQ
+    aicwf_prealloc_txq_free();
+#endif
 	printk("%s\n", __func__);
 }
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
old mode 100755
new mode 100644
index 02db71086..2e50ac995
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
@@ -43,18 +43,18 @@ extern void set_power_control_lock(int lock);
 static int aicbsp_platform_power_on(void);
 static void aicbsp_platform_power_off(void);
 
-struct aic_sdio_dev *aicbsp_sdiodev;
+struct aic_sdio_dev *aicbsp_sdiodev = NULL;
 static struct semaphore *aicbsp_notify_semaphore;
 static const struct sdio_device_id aicbsp_sdmmc_ids[];
 static bool aicbsp_load_fw_in_fdrv = false;
 
 #define FW_PATH_MAX 200
 
-#ifdef CONFIG_PLATFORM_UBUNTU
-static const char* aic_default_fw_path = "/lib/firmware/aic8800_sdio";
-#else
+//#ifdef CONFIG_PLATFORM_UBUNTU
+//static const char* aic_default_fw_path = "/lib/firmware/aic8800_sdio";
+//#else
 static const char* aic_default_fw_path = CONFIG_AIC_FW_PATH;
-#endif
+//#endif
 char aic_fw_path[FW_PATH_MAX];
 module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
 
@@ -166,7 +166,9 @@ int aicbsp_set_subsys(int subsys, int state)
 				goto err1;
 			if (aicbsp_driver_fw_init(aicbsp_sdiodev))
 				goto err2;
+#ifndef CONFIG_FDRV_NO_REG_SDIO
 			aicbsp_sdio_release(aicbsp_sdiodev);
+#endif
 
 #ifdef CONFIG_PLATFORM_ROCKCHIP
 #ifdef CONFIG_GPIO_WAKEUP
@@ -232,6 +234,15 @@ static int aicwf_sdio_chipmatch(struct aic_sdio_dev *sdio_dev, uint16_t vid, uin
 	}
 }
 
+void *aicbsp_get_drvdata(void *args)
+{
+	(void)args;
+	if (aicbsp_sdiodev)
+		return aicbsp_sdiodev->bus_if;
+	return dev_get_drvdata((const struct device *)args);
+}
+
+
 static int aicbsp_sdio_probe(struct sdio_func *func,
 	const struct sdio_device_id *id)
 {
@@ -331,16 +342,20 @@ static void aicbsp_sdio_remove(struct sdio_func *func)
 		return;
 	}
 
-	func = aicbsp_sdiodev->func;
-	host = func->card->host;
-	//host->caps &= ~MMC_CAP_NONREMOVABLE;
-	bus_if = dev_get_drvdata(&func->dev);
+    bus_if = aicbsp_get_drvdata(&func->dev);
+	
 	if (!bus_if) {
+        AICWFDBG(LOGERROR, "%s bus_if is NULL \r\n", __func__);
 		return;
 	}
 
+	func = aicbsp_sdiodev->func;
+	host = func->card->host;
+	host->caps &= ~MMC_CAP_NONREMOVABLE;
+
 	sdiodev = bus_if->bus_priv.sdio;
 	if (!sdiodev) {
+        AICWFDBG(LOGERROR, "%s sdiodev is NULL \r\n", __func__);
 		return;
 	}
 
@@ -359,6 +374,14 @@ static int aicbsp_sdio_suspend(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	int err;
 	mmc_pm_flag_t sdio_flags;
+    
+#ifdef CONFIG_PLATFORM_ROCKCHIP
+#ifdef CONFIG_GPIO_WAKEUP
+    //BT_SLEEP:true,BT_WAKEUP:false
+    rfkill_rk_sleep_bt(false);
+#endif
+#endif
+
 	sdio_dbg("%s, func->num = %d\n", __func__, func->num);
 	if (func->num != 2)
 		return 0;
@@ -391,13 +414,7 @@ static int aicbsp_sdio_suspend(struct device *dev)
 static int aicbsp_sdio_resume(struct device *dev)
 {
 	sdio_dbg("%s\n", __func__);
-#ifdef CONFIG_PLATFORM_ROCKCHIP
-#ifdef CONFIG_GPIO_WAKEUP
-			//BT_SLEEP:true,BT_WAKEUP:false
-			rfkill_rk_sleep_bt(false);
-			printk("%s BT wake to WAKEUP\r\n", __func__);
-#endif
-#endif
+
 	return 0;
 }
 
@@ -827,7 +844,7 @@ static int aicwf_sdio_intr_get_len_bytemode(struct aic_sdio_dev *sdiodev, u8 *by
 
 static void aicwf_sdio_bus_stop(struct device *dev)
 {
-	struct aicwf_bus *bus_if = dev_get_drvdata(dev);
+	struct aicwf_bus *bus_if = aicbsp_get_drvdata(dev);
 	struct aic_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
 	int ret;
 
@@ -1362,6 +1379,13 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
 	struct sk_buff *pkt = NULL;
 	int ret;
 
+    //AICWFDBG(LOGDEBUG,"%s bsp enter \r\n", __func__);
+
+    if(aicbsp_sdiodev->sdio_hal_irqhandler){
+        aicbsp_sdiodev->sdio_hal_irqhandler(func);
+        return;
+    }
+
 	if (!bus_if || bus_if->state == BUS_DOWN_ST) {
 		sdio_err("bus err\n");
 		return;
@@ -1552,7 +1576,7 @@ void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 
 	sdio_dbg("%s\n", __func__);
 
-	bus_if = dev_get_drvdata(sdiodev->dev);
+	bus_if = aicbsp_get_drvdata(sdiodev->dev);
 	bus_if->state = BUS_DOWN_ST;
 
 	sdio_claim_host(sdiodev->func);
@@ -1710,7 +1734,7 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 	struct mmc_host *host;
 	u8 byte_mode_disable = 0x1;//1: no byte mode
 	int ret = 0;
-    u8 val;
+    //u8 val;
 	struct aicbsp_feature_t feature;
 
 	aicbsp_get_feature(&feature, NULL);
@@ -1720,12 +1744,27 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 
 	sdio_claim_host(sdiodev->func);
 	sdiodev->func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+
+	ret = sdio_set_block_size(sdiodev->func, SDIOWIFI_FUNC_BLOCKSIZE);
+	if (ret < 0) {
+		sdio_err("set blocksize fail %d\n", ret);
+		sdio_release_host(sdiodev->func);
+		return ret;
+	}
+	ret = sdio_enable_func(sdiodev->func);
+	if (ret < 0) {
+        sdio_err("enable func fail %d.\n", ret);
+		sdio_release_host(sdiodev->func);
+		return ret;
+	}
+
     sdio_f0_writeb(sdiodev->func, 0x7F, 0xF2, &ret);
     if (ret) {
         sdio_err("set fn0 0xF2 fail %d\n", ret);
         sdio_release_host(sdiodev->func);
         return ret;
     }
+#if 0
     if (host->ios.timing == MMC_TIMING_UHS_DDR50) {
         val = 0x21;//0x1D;//0x5;
     } else {
@@ -1744,13 +1783,13 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
         sdio_release_host(sdiodev->func);
         return ret;
     }
-    sdio_f0_writeb(sdiodev->func, 0x20, 0xF1, &ret);
+    sdio_f0_writeb(sdiodev->func, 0x40, 0xF1, &ret);
     if (ret) {
         sdio_err("set iopad delay1 fail %d\n", ret);
         sdio_release_host(sdiodev->func);
         return ret;
     }
-    udelay(100);
+    msleep(1);
 #if 1//SDIO CLOCK SETTING
 	if ((feature.sdio_clock > 0) && (host->ios.timing != MMC_TIMING_UHS_DDR50)) {
 		host->ios.clock = feature.sdio_clock;
@@ -1758,18 +1797,7 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 		sdio_dbg("Set SDIO Clock %d MHz\n", host->ios.clock/1000000);
 	}
 #endif
-	ret = sdio_set_block_size(sdiodev->func, SDIOWIFI_FUNC_BLOCKSIZE);
-	if (ret < 0) {
-		sdio_err("set blocksize fail %d\n", ret);
-		sdio_release_host(sdiodev->func);
-		return ret;
-	}
-	ret = sdio_enable_func(sdiodev->func);
-	if (ret < 0) {
-        sdio_err("enable func fail %d.\n", ret);
-		sdio_release_host(sdiodev->func);
-		return ret;
-	}
+#endif
 	sdio_release_host(sdiodev->func);
 
 	//1: no byte mode
@@ -1878,6 +1906,14 @@ int get_testmode(void){
 	return testmode;
 }
 
+struct sdio_func *get_sdio_func(void){
+    return aicbsp_sdiodev->func;
+}
+
+void set_irq_handler(void *fn){
+    aicbsp_sdiodev->sdio_hal_irqhandler = (sdio_irq_handler_t *)fn;
+}
+
 uint8_t crc8_ponl_107(uint8_t *p_buffer, uint16_t cal_size)
 {
     uint8_t i;
@@ -1903,5 +1939,7 @@ uint8_t crc8_ponl_107(uint8_t *p_buffer, uint16_t cal_size)
 }
 
 EXPORT_SYMBOL(get_fw_path);
-
 EXPORT_SYMBOL(get_testmode);
+EXPORT_SYMBOL(get_sdio_func);
+EXPORT_SYMBOL(set_irq_handler);
+
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
old mode 100755
new mode 100644
index f621e8fed..582ba94df
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
@@ -109,6 +109,7 @@ struct aic_sdio_dev {
 #endif
 	u16 chipid;
     struct aic_sdio_reg sdio_reg;
+    void (*sdio_hal_irqhandler) (struct sdio_func *func);
 };
 
 void *aicbsp_get_drvdata(void *args);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.c
old mode 100755
new mode 100644
index fcb42f02c..37297f1b8
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.c
@@ -73,7 +73,7 @@ void aicwf_bus_deinit(struct device *dev)
 		return;
 	}
 	sdio_dbg("%s", __func__);
-	bus_if = dev_get_drvdata(dev);
+	bus_if = aicbsp_get_drvdata(dev);
 	aicwf_bus_stop(bus_if);
 
 	sdiodev = bus_if->bus_priv.sdio;
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio_txrxif.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_firmware_array.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.c
new file mode 100644
index 000000000..fc098af5b
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.c
@@ -0,0 +1,62 @@
+#include <linux/slab.h>
+#include "aicsdio_txrxif.h"
+#include "aic_bsp_driver.h"
+
+struct prealloc_txq{
+    int prealloced;
+    void *txq;
+    size_t size;
+};
+
+struct prealloc_txq prealloc_txq;
+#define MAX_TXQ_SIZE 30 * 1024
+
+void *aicwf_prealloc_txq_alloc(size_t size)
+{
+
+    BUG_ON(size > MAX_TXQ_SIZE);
+
+    //check prealloc_txq.size
+    if((int)prealloc_txq.size != (int)size)
+    {
+        AICWFDBG(LOGINFO, "%s size is diff will to be kzalloc \r\n", __func__);
+
+        if(prealloc_txq.txq != NULL)
+        {
+            AICWFDBG(LOGINFO, "%s txq to kfree \r\n", __func__);
+            kfree(prealloc_txq.txq);
+            prealloc_txq.txq = NULL;
+        }
+        
+        prealloc_txq.size = size;
+        prealloc_txq.prealloced = 0;
+    }
+
+    //check prealloc or not
+    if(!prealloc_txq.prealloced)
+    {
+        prealloc_txq.txq = kzalloc(size, GFP_KERNEL);
+        if(!prealloc_txq.txq){
+            AICWFDBG(LOGERROR, "%s txq kzalloc fail \r\n", __func__);
+        }else{
+            AICWFDBG(LOGINFO, "%s txq kzalloc successful \r\n", __func__);
+            prealloc_txq.prealloced = 1;
+        }
+    }else{
+         AICWFDBG(LOGINFO, "%s txq not need to kzalloc \r\n", __func__);
+    }
+
+    return prealloc_txq.txq;
+}
+void aicwf_prealloc_txq_free(void)
+{
+    if(prealloc_txq.txq != NULL)
+    {
+        AICWFDBG(LOGINFO, "%s txq to kfree \r\n", __func__);
+        kfree(prealloc_txq.txq);
+        prealloc_txq.txq = NULL;
+    }
+}
+
+EXPORT_SYMBOL(aicwf_prealloc_txq_alloc);
+
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.h
new file mode 100644
index 000000000..ce4ee0747
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicwf_txq_prealloc.h
@@ -0,0 +1,4 @@
+
+
+void aicwf_prealloc_txq_free(void);
+
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/md5.c b/drivers/net/wireless/aic8800/aic8800_bsp/md5.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/md5.h b/drivers/net/wireless/aic8800/aic8800_bsp/md5.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
old mode 100755
new mode 100644
index 3b17821a9..668212830
--- a/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "241c091M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - - 241c091M (master)"
-#define RELEASE_DATE "2023_0207_1037"
+#define RELEASE_DATE "2023_0904_1726"
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/Kconfig b/drivers/net/wireless/aic8800/aic8800_btlpm/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/Makefile b/drivers/net/wireless/aic8800/aic8800_btlpm/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c b/drivers/net/wireless/aic8800/aic8800_btlpm/aic8800_btlpm.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/aic_bluetooth_main.c b/drivers/net/wireless/aic8800/aic8800_btlpm/aic_bluetooth_main.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_btlpm/aic_bsp_export.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.c b/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.c
old mode 100755
new mode 100644
index 551f61899..26195f472
--- a/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.c
+++ b/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.c
@@ -392,22 +392,20 @@ static ssize_t bluesleep_write_proc_btwrite(struct file *file,
 	return count;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0)
 static const struct proc_ops lpm_fops = {
-	.proc_open		= bluesleep_lpm_proc_open,
-	.proc_read		= seq_read,
-	.proc_lseek		= seq_lseek,
+	.proc_open	= bluesleep_lpm_proc_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
 	.proc_release	= single_release,
-	.proc_write		= bluesleep_write_proc_lpm,
-
+	.proc_write	= bluesleep_write_proc_lpm,
 };
 static const struct proc_ops btwrite_fops = {
-	.proc_open		= bluesleep_btwrite_proc_open,
-	.proc_read		= seq_read,
-	.proc_lseek		= seq_lseek,
+	.proc_open	= bluesleep_btwrite_proc_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
 	.proc_release	= single_release,
-	.proc_write		= bluesleep_write_proc_btwrite,
-
+	.proc_write	= bluesleep_write_proc_btwrite,
 };
 #else
 static const struct file_operations lpm_fops = {
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.h b/drivers/net/wireless/aic8800/aic8800_btlpm/lpm.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.c b/drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.h b/drivers/net/wireless/aic8800/aic8800_btlpm/rfkill.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Kconfig b/drivers/net/wireless/aic8800/aic8800_fdrv/Kconfig
old mode 100755
new mode 100644
index 38b96d50c..c26f2b4af
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Kconfig
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Kconfig
@@ -2,3 +2,4 @@ config AIC8800_WLAN_SUPPORT
 	tristate "AIC8800 wlan Support"
 	help
 	  This is support for aic wifi driver.
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
old mode 100755
new mode 100644
index 447f71825..623643e64
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -2,7 +2,6 @@ RWNX_VERS_NUM := 6.4.3.0
 
 CONFIG_COUNTRY_CODE = "00"
 
-
 MODULE_NAME = aic8800_fdrv
 
 # Support of bootrom start
@@ -45,7 +44,7 @@ CONFIG_RWNX_TL4 ?= n
 CONFIG_RWNX_OLD_IPC ?= n
 
 # Support of P2P DebugFS for enabling/disabling NoA and OppPS
-CONFIG_RWNX_P2P_DEBUGFS := y
+CONFIG_RWNX_P2P_DEBUGFS := n
 #
 # } // WAITING FOR KCONFIG
 #
@@ -68,12 +67,12 @@ CONFIG_DOWNLOAD_FW =n
 CONFIG_RFTEST=y
 CONFIG_USB_BT =y
 CONFIG_USE_5G ?= y
-CONFIG_SDIO_PWRCTRL ?= n
+CONFIG_SDIO_PWRCTRL ?= y
 CONFIG_CREATE_TRACE_POINTS = n
 CONFIG_TXRX_THREAD_PRIO = n
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
-CONFIG_RX_NETIF_RECV_SKB = n
+CONFIG_RX_NETIF_RECV_SKB = y
 CONFIG_GPIO_WAKEUP = n
 CONFIG_SET_VENDOR_EXTENSION_IE = n
 CONFIG_SUPPORT_REALTIME_CHANGE_MAC = y
@@ -87,7 +86,13 @@ CONFIG_USE_FW_REQUEST = n
 CONFIG_USE_P2P0=n
 CONFIG_BR_SUPPORT =n
 BR_NAME = br0
-
+CONFIG_FDRV_NO_REG_SDIO=n
+CONFIG_SCHED_SCAN = y
+CONFIG_OOB = n
+CONFIG_USE_CUSTOMER_MAC = n
+CONFIG_PREALLOC_TXQ = y
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
 
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
@@ -107,8 +112,8 @@ CONFIG_RWNX_MON_DATA =y
 
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
-CONFIG_RWNX_DBG ?= n
-CONFIG_DEBUG_FS ?= y
+CONFIG_RWNX_DBG ?= y
+CONFIG_DEBUG_FS ?= n
 
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) := $(MODULE_NAME).o
 $(MODULE_NAME)-y := \
@@ -136,6 +141,7 @@ $(MODULE_NAME)-y := \
 	md5.o                  \
 	aicwf_compat_8800dc.o  \
 	aicwf_compat_8800d80.o \
+	rwnx_wakelock.o		\
 	regdb.o				   \
 	aicwf_rx_prealloc.o
 
@@ -218,7 +224,13 @@ ccflags-$(CONFIG_PREALLOC_RX_SKB) += -DCONFIG_PREALLOC_RX_SKB
 ccflags-$(CONFIG_WIFI_SUSPEND_FOR_LINUX) += -DCONFIG_WIFI_SUSPEND_FOR_LINUX
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
 ccflags-$(CONFIG_USE_P2P0) += -DCONFIG_USE_P2P0
-
+ccflags-$(CONFIG_FDRV_NO_REG_SDIO) += -DCONFIG_FDRV_NO_REG_SDIO
+ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
+ccflags-$(CONFIG_OOB) += -DCONFIG_OOB
+ccflags-$(CONFIG_USE_CUSTOMER_MAC) += -DCONFIG_USE_CUSTOMER_MAC
+ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
+ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
+ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
 
 
 ifeq ($(CONFIG_SDIO_SUPPORT), y)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_br_ext.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
old mode 100755
new mode 100644
index 9dfd78ded..adf8f55ec
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
@@ -1,6 +1,8 @@
 #ifndef __AIC_BSP_EXPORT_H
 #define __AIC_BSP_EXPORT_H
 
+#define AICBSP_RESV_MEM_SUPPORT 0
+
 enum aicbsp_subsys {
 	AIC_BLUETOOTH,
 	AIC_WIFI,
@@ -18,8 +20,14 @@ struct aicbsp_feature_t {
     int fwlog_en;
 };
 
+enum skb_buff_id {
+	AIC_RESV_MEM_TXDATA,
+};
+
 int aicbsp_set_subsys(int, int);
 int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path);
 bool aicbsp_get_load_fw_in_fdrv(void);
+struct sk_buff *aicbsp_resv_mem_alloc_skb(unsigned int length, uint32_t id);
+void aicbsp_resv_mem_kfree_skb(struct sk_buff *skb, uint32_t id);
 
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
old mode 100755
new mode 100644
index 5ee32a8f8..6e8469d64
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -843,7 +843,20 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		.policy = aicwf_cfg80211_subcmd_set_mac_policy,
 		.maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
 #endif
-    },
+    	},
+	{
+        {
+         .vendor_id = BRCM_OUI,
+         .subcmd = VENDOR_NL80211_SUBCMD_SET_MAC
+        },
+        .flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
+        .doit = aicwf_vendor_sub_cmd_set_mac,
+        .dumpit = aicwf_dump_interface,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+        .policy = aicwf_cfg80211_subcmd_set_mac_policy,
+        .maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
+#endif
+    	},
 };
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
old mode 100755
new mode 100644
index 765408791..0e1e3e0c7
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
@@ -4,6 +4,7 @@
 #include <linux/types.h>
 
 #define GOOGLE_OUI     0x001A11
+#define BRCM_OUI       0x001018
 
 typedef enum {
 	START_MKEEP_ALIVE,
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
old mode 100755
new mode 100644
index 008919361..72eeb93ce
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
@@ -20,7 +20,7 @@ int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_
 		return -1;
 	}
 
-	if ((ret = rwnx_send_txpwr_ofst_req(rwnx_hw))) {
+	if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
 		return -1;
 	}
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
old mode 100755
new mode 100644
index 109a6b910..337fe6266
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -5,6 +5,10 @@
 #define RWNX_MAC_RF_PATCH_BASE_NAME_8800DC     "fmacfw_rf_patch_8800dc"
 #define RWNX_MAC_RF_PATCH_NAME_8800DC RWNX_MAC_RF_PATCH_BASE_NAME_8800DC".bin"
 #define FW_USERCONFIG_NAME_8800DC         "aic_userconfig_8800dc.txt"
+#define FW_USERCONFIG_NAME_8800DW         "aic_userconfig_8800dw.txt"
+#ifdef CONFIG_DPD
+#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_8800dc.bin"
+#endif
 
 int rwnx_plat_bin_fw_upload_2(struct rwnx_hw *rwnx_hw, u32 fw_addr,
                                char *filename);
@@ -14,180 +18,339 @@ void rwnx_plat_userconfig_parsing2(char *buffer, int size);
 
 void rwnx_release_firmware_common(u32** buffer);
 
-uint32_t txgain_table[32] =
+u32 wifi_txgain_table_24g_8800dcdw[32] =
 {
-    0xA4B22189,
+    0xA4B22189, //index 0
     0x00007825,
-    0xA4B2214B,
+    0xA4B2214B, //index 1
     0x00007825,
-    0xA4B2214F,
+    0xA4B2214F, //index 2
     0x00007825,
-    0xA4B221D5,
+    0xA4B221D5, //index 3
     0x00007825,
-    0xA4B221DC,
+    0xA4B221DC, //index 4
     0x00007825,
-    0xA4B221E5,
+    0xA4B221E5, //index 5
     0x00007825,
-    0xAC9221E5,
+    0xAC9221E5, //index 6
     0x00006825,
-    0xAC9221EF,
+    0xAC9221EF, //index 7
     0x00006825,
-    0xBC9221EE,
+    0xBC9221EE, //index 8
     0x00006825,
-    0xBC9221FF,
+    0xBC9221FF, //index 9
     0x00006825,
-    0xBC9221FF,
+    0xBC9221FF, //index 10
     0x00004025,
-    0xB792203F,
+    0xB792203F, //index 11
     0x00004026,
-    0xDC92203F,
+    0xDC92203F, //index 12
     0x00004025,
-    0xE692203F,
+    0xE692203F, //index 13
     0x00004025,
-    0xFF92203F,
+    0xFF92203F, //index 14
     0x00004035,
-    0xFFFE203F,
+    0xFFFE203F, //index 15
     0x00004832
 };
 
-uint32_t rxgain_table_24g_20m[64] = {
-    0x82f282d1,
+u32 wifi_txgain_table_24g_1_8800dcdw[32] =
+{
+    0x096E2011, //index 0
+    0x00004001,
+    0x096E2015, //index 1
+    0x00004001,
+    0x096E201B, //index 2
+    0x00004001,
+    0x116E2018, //index 3
+    0x00004001,
+    0x116E201E, //index 4
+    0x00004001,
+    0x116E2023, //index 5
+    0x00004001,
+    0x196E2021, //index 6
+    0x00004001,
+    0x196E202B, //index 7
+    0x00004001,
+    0x216E202B, //index 8
+    0x00004001,
+    0x236E2027, //index 9
+    0x00004001,
+    0x236E2031, //index 10
+    0x00004001,
+    0x246E2039, //index 11
+    0x00004001,
+    0x26922039, //index 12
+    0x00004001,
+    0x2E92203F, //index 13
+    0x00004001,
+    0x3692203F, //index 14
+    0x00004001,
+    0x3FF2203F, //index 15
+    0x00004001,
+};
+
+u32 wifi_txgain_table_24g_8800dcdw_h[32] =
+{
+    0xA55629C9, //index 0
+    0x00005825,
+    0xAE5629C9, //index 1
+    0x00005825,
+    0xAD5629CD, //index 2
+    0x00005825,
+    0xAD5629D1, //index 3
+    0x00005825,
+    0xAD5629D7, //index 4
+    0x00005825,
+    0xAD5629DE, //index 5
+    0x00005825,
+    0xAD5629E6, //index 6
+    0x00005825,
+    0xBD5629E6, //index 7
+    0x00005825,
+    0xBD5629F0, //index 8
+    0x00005825,
+    0xCD5629F0, //index 9
+    0x00005825,
+    0xE55629F0, //index 10
+    0x00005825,
+    0xE55629FF, //index 11
+    0x00005825,
+    0xE55629FF, //index 12
+    0x00002825,
+    0xE75629FF, //index 13
+    0x00002825,
+    0xFF5629FF, //index 14
+    0x00001825,
+    0xFF5628FF, //index 15
+    0x00001025,
+};
+
+u32 wifi_txgain_table_24g_1_8800dcdw_h[32] =
+{
+    0x941A2048, //index 0
+    0x00001825,
+    0x961A2048, //index 1
+    0x00001825,
+    0x9D1A2048, //index 2
+    0x00001825,
+    0x9A1A204F, //index 3
+    0x00001825,
+    0x961A204F, //index 4
+    0x00001825,
+    0x9A1A2057, //index 5
+    0x00001825,
+    0x9C1A2057, //index 6
+    0x00001825,
+    0xA31A205B, //index 7
+    0x00001825,
+    0xAB1A205B, //index 8
+    0x00001825,
+    0xAD1A205B, //index 9
+    0x00001825,
+    0xA71A2064, //index 10
+    0x00001825,
+    0xAD1A2070, //index 11
+    0x00001825,
+    0xAD72207F, //index 12
+    0x00001825,
+    0xBCAE207F, //index 13
+    0x00001825,
+    0xBFB2207F, //index 14
+    0x00001825,
+    0xD73A207F, //index 15
+    0x00001825,
+};
+
+u32 wifi_rxgain_table_24g_20m_8800dcdw[64] = {
+    0x82f282d1,//index 0
     0x9591a324,
     0x80808419,
     0x000000f0,
-    0x42f282d1,
+    0x42f282d1,//index 1
     0x95923524,
     0x80808419,
     0x000000f0,
-    0x22f282d1,
+    0x22f282d1,//index 2
     0x9592c724,
     0x80808419,
     0x000000f0,
-    0x02f282d1,
+    0x02f282d1,//index 3
     0x9591a324,
     0x80808419,
     0x000000f0,
-    0x06f282d1,
+    0x06f282d1,//index 4
     0x9591a324,
     0x80808419,
     0x000000f0,
-    0x0ef29ad1,
+    0x0ef29ad1,//index 5
     0x9591a324,
     0x80808419,
     0x000000f0,
-    0x0ef29ad3,
+    0x0ef29ad3,//index 6
     0x95923524,
     0x80808419,
     0x000000f0,
-    0x0ef29ad7,
+    0x0ef29ad7,//index 7
     0x9595a324,
     0x80808419,
     0x000000f0,
-    0x06f282d2,
-    0x95911124,
-    0x80808419,
-    0x000000f0,
-    0x06f282f4,
-    0x95911124,
+    0x02f282d2,//index 8
+    0x95951124,
     0x80808419,
     0x000000f0,
-    0x06f282e6,
-    0x9591a324,
+    0x02f282f4,//index 9
+    0x95951124,
     0x80808419,
     0x000000f0,
-    0x06f282e6,
+    0x02f282e6,//index 10
     0x9595a324,
     0x80808419,
     0x000000f0,
-    0x06f282e6,
+    0x02f282e6,//index 11
     0x9599a324,
     0x80808419,
     0x000000f0,
-    0x06f282e6,
-    0x959b5924,
+    0x02f282e6,//index 12
+    0x959da324,
     0x80808419,
     0x000000f0,
-    0x06f282e6,
+    0x02f282e6,//index 13
     0x959f5924,
     0x80808419,
     0x000000f0,
-    0x0ef29ae6,
+    0x06f282e6,//index 14
     0x959f5924,
     0x80808419,
+    0x000000f0,
+    0x0ef29ae6,//index 15
+    0x959f5924,           //loft [35:34]=3
+    0x80808419,
     0x000000f0
 };
 
-
-
-uint32_t rxgain_table_24g_40m[64] = {
-    0x83428151,
+u32 wifi_rxgain_table_24g_40m_8800dcdw[64] = {
+    0x83428151,//index 0
     0x9631a328,
     0x80808419,
     0x000000f0,
-    0x43428151,
+    0x43428151,//index 1
     0x96323528,
     0x80808419,
     0x000000f0,
-    0x23428151,
+    0x23428151,//index 2
     0x9632c728,
     0x80808419,
     0x000000f0,
-    0x03428151,
+    0x03428151,//index 3
     0x9631a328,
     0x80808419,
     0x000000f0,
-    0x07429951,
+    0x07429951,//index 4
     0x9631a328,
     0x80808419,
     0x000000f0,
-    0x0f42d151,
+    0x0f42d151,//index 5
     0x9631a328,
     0x80808419,
     0x000000f0,
-    0x0f42d153,
+    0x0f42d153,//index 6
     0x96323528,
     0x80808419,
     0x000000f0,
-    0x0f42d157,
+    0x0f42d157,//index 7
     0x9635a328,
     0x80808419,
     0x000000f0,
-    0x07429952,
-    0x96311128,
-    0x80808419,
-    0x000000f0,
-    0x07429974,
-    0x96311128,
+    0x03428152,//index 8
+    0x96351128,
     0x80808419,
     0x000000f0,
-    0x07429966,
-    0x9631a328,
+    0x03428174,//index 9
+    0x96351128,
     0x80808419,
     0x000000f0,
-    0x07429966,
+    0x03428166,//index 10
     0x9635a328,
     0x80808419,
     0x000000f0,
-    0x07429966,
+    0x03428166,//index 11
     0x9639a328,
     0x80808419,
     0x000000f0,
-    0x07429966,
-    0x963b5928,
+    0x03428166,//index 12
+    0x963da328,
     0x80808419,
     0x000000f0,
-    0x07429966,
+    0x03428166,//index 13
     0x963f5928,
     0x80808419,
     0x000000f0,
-    0x0f42d166,
+    0x07429966,//index 14
+    0x963f5928,
+    0x80808419,
+    0x000000f0,
+    0x0f42d166,//index 15
     0x963f5928,
     0x80808419,
     0x000000f0
 };
 
+#ifdef CONFIG_DPD
+#define RAM_LMAC_FW_ADDR               0x00150000
+extern int is_file_exist(char* name);
 
+int aicwf_fdrv_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
 
+	printk("%s\n", __func__);
+    if (testmode == 1) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, misc_ram_addr, FW_DPDRESULT_NAME_8800DC);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    return ret;
+}
+#endif
+
+int aicwf_fdrv_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    const uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t misc_ram_size = 12;
+    int i;
+    // init misc ram
+    printk("%s\n", __func__);
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGERROR, "misc_ram_addr=%x\n", misc_ram_addr);
+    for (i = 0; i < (misc_ram_size / 4); i++) {
+        ret = rwnx_send_dbg_mem_write_req(rwnx_hw, misc_ram_addr + i * 4, 0);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] wr fail: %d\n",  misc_ram_addr + i * 4, ret);
+            return ret;
+        }
+    }
+    return ret;
+}
 
 
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm){
@@ -203,18 +366,47 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 
 
 	if (testmode == 0) {
-		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	1, (u8_l *)txgain_table, 128)))
-			return -1;
+        if (IS_CHIP_ID_H()) {
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_h, 128)))
+                return -1;
+
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw_h, 128)))
+                return -1;
+        } else {
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw, 128)))
+                return -1;
 
-		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	0, (u8_l *)rxgain_table_24g_20m, 256)))
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw, 128)))
+                return -1;
+        }
+
+		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	0, (u8_l *)wifi_rxgain_table_24g_20m_8800dcdw, 256)))
 			return -1;
 
-		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 32,  0, (u8_l *)rxgain_table_24g_40m, 256)))
+		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 32,  0, (u8_l *)wifi_rxgain_table_24g_40m_8800dcdw, 256)))
 			return -1;
 
 		if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
 			return -1;
 		}
+	} else if (testmode == 1) {
+		if (chip_sub_id == 1) {
+            #ifdef CONFIG_DPD
+            if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
+                AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
+                ret = aicwf_fdrv_dpd_result_load_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #endif
+            ret = rwnx_send_rf_calib_req(rwnx_hw, cfm);
+            if (ret) {
+                AICWFDBG(LOGINFO, "rf calib req fail: %d\n", ret);
+                return ret;
+            }
+        }
 	}
 
 	return 0 ;
@@ -247,4 +439,30 @@ int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw){
 
 }
 
+int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw){
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800DC;
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing2((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
old mode 100755
new mode 100644
index a6a1dd674..7b591dbf5
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
@@ -1,6 +1,11 @@
 #include <linux/types.h>
 
+#ifdef CONFIG_DPD
+int aicwf_fdrv_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw);
+#endif
+int aicwf_fdrv_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw);
+int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw);
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
old mode 100755
new mode 100644
index 12fdca688..25a576656
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
@@ -10,6 +10,10 @@
 #define LOGTRACE		0x0004
 #define LOGDEBUG		0x0008
 #define LOGDATA			0x0010
+#define LOGIRQ			0x0020
+#define LOGSDPWRC		0x0040
+#define LOGWAKELOCK		0x0080
+#define LOGRXPOLL		0x0100
 
 extern int aicwf_dbg_level;
 void rwnx_data_dump(char* tag, void* data, unsigned long len);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
old mode 100755
new mode 100644
index 9c992f7cf..66fc7e528
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
@@ -23,7 +23,10 @@
 #include "aicwf_rx_prealloc.h"
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
 #include <linux/pm_wakeirq.h>
+#else
+#include <linux/pm_wakeup.h>
 #endif
+#include "rwnx_wakelock.h"
 
 #ifdef CONFIG_INGENIC_T20
 #include "mach/jzmmc.h"
@@ -219,7 +222,7 @@ static u32 hostwake_irq_num;
 //static struct wakeup_source *ws_sdio_pwrctrl;
 //static struct wakeup_source *ws_tx_sdio;
 #ifdef CONFIG_GPIO_WAKEUP
-static struct wakeup_source *ws;
+//static struct wakeup_source *ws;
 #endif
 #else
 #ifdef ANDROID_PLATFORM
@@ -253,17 +256,16 @@ static struct wake_lock irq_wakelock;
 #endif
 #endif
 
-
+#if 0
 void rwnx_pm_stay_awake(struct aic_sdio_dev *sdiodev){
 
 #ifdef CONFIG_GPIO_WAKEUP
 	spin_lock_bh(&sdiodev->wslock);
 
-
-		//printk("%s active_count:%d relax_count:%d\r\n", __func__, (int)ws->active_count, (int)ws->relax_count);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 		if(ws != NULL){
 			__pm_stay_awake(ws);
+            AICWFDBG(LOGWAKELOCK, "%s active_count:%d relax_count:%d\r\n", __func__, (int)ws->active_count, (int)ws->relax_count);
 		}
 #else
 #ifdef ANDROID_PLATFORM
@@ -282,11 +284,10 @@ void rwnx_pm_relax(struct aic_sdio_dev *sdiodev){
 #ifdef CONFIG_GPIO_WAKEUP
 	spin_lock_bh(&sdiodev->wslock);
 
-
-	//printk("%s active_count:%d relax_count:%d\r\n", __func__, (int)ws->active_count, (int)ws->relax_count);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	if(ws != NULL){
 		__pm_relax(ws);
+        AICWFDBG(LOGWAKELOCK, "%s active_count:%d relax_count:%d\r\n", __func__, (int)ws->active_count, (int)ws->relax_count);
 	}
 #else
 #ifdef ANDROID_PLATFORM
@@ -299,6 +300,8 @@ void rwnx_pm_relax(struct aic_sdio_dev *sdiodev){
 #endif
 
 }
+#endif
+
 
 #ifdef CONFIG_GPIO_WAKEUP
 
@@ -310,19 +313,23 @@ static irqreturn_t rwnx_hostwake_irq_handler(int irq, void *para)
 	static int wake_cnt;
 	wake_cnt++;
 
-#if 1
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
-	__pm_wakeup_event(ws, HZ);
+	rwnx_wakeup_lock_timeout(g_rwnx_plat->sdiodev->rwnx_hw->ws_rx, 1000);
 #else
 #ifdef ANDROID_PLATFORM
 	wake_lock_timeout(&irq_wakelock, HZ);
 #endif //ANDROID_PLATFORM
-#endif
 #endif
 
-	//rwnx_pm_stay_awake(g_rwnx_plat->sdiodev);
+	AICWFDBG(LOGIRQ, "%s(%d): wake_irq_cnt = %d\n", __func__, __LINE__, wake_cnt);
 
-	AICWFDBG(LOGDEBUG, "%s(%d): wake_irq_cnt = %d\n", __func__, __LINE__, wake_cnt);
+#ifdef CONFIG_OOB
+#if 0//old oob feature
+    complete(&g_rwnx_plat->sdiodev->bus_if->busrx_trgg);
+#else//new oob feature
+    complete(&g_rwnx_plat->sdiodev->bus_if->busirq_trgg);
+#endif//old oob feature
+#endif
 
 	return IRQ_HANDLED;
 }
@@ -363,7 +370,7 @@ static int rwnx_register_hostwake_irq(struct device *dev)
 
 	if (wakeup_enable) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
-		ws = wakeup_source_register(dev, "wifisleep");
+		//ws = wakeup_source_register(dev, "wifisleep");
 		//ws_tx_sdio = wakeup_source_register(dev, "wifi_tx_sleep");
 		//ws_rx_sdio = wakeup_source_register(dev, "wifi_rx_sleep");
 		//ws_sdio_pwrctrl = wakeup_source_register(dev, "sdio_pwrctrl_sleep");
@@ -395,9 +402,11 @@ static int rwnx_register_hostwake_irq(struct device *dev)
 	}
 	//disable_irq(hostwake_irq_num);
 	rwnx_disable_hostwake_irq();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
 	dev_pm_clear_wake_irq(dev);
+#endif
 	rwnx_enable_hostwake_irq();
-	printk("%s(%d)\n", __func__, __LINE__);
+	AICWFDBG(LOGINFO, "%s(%d)\n", __func__, __LINE__);
 	return ret;
 
 fail2:
@@ -407,7 +416,7 @@ static int rwnx_register_hostwake_irq(struct device *dev)
 fail1:
 	device_init_wakeup(dev, false);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
-	wakeup_source_unregister(ws);
+	//wakeup_source_unregister(ws);
 	//wakeup_source_unregister(ws_tx_sdio);
 	//wakeup_source_unregister(ws_rx_sdio);
 	//wakeup_source_unregister(ws_sdio_pwrctrl);
@@ -430,7 +439,7 @@ static int rwnx_unregister_hostwake_irq(struct device *dev)
 	AICWFDBG(LOGERROR, "%s kernel unsupport this feature!\r\n", __func__);
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
-		wakeup_source_unregister(ws);
+		//wakeup_source_unregister(ws);
 		//wakeup_source_unregister(ws_tx_sdio);
 		//wakeup_source_unregister(ws_rx_sdio);
 		//wakeup_source_unregister(ws_sdio_pwrctrl);
@@ -453,13 +462,13 @@ static int rwnx_enable_hostwake_irq(void)
 	enable_irq(hostwake_irq_num);
 	enable_irq_wake(hostwake_irq_num);
 #endif//CONFIG_GPIO_WAKEUP
-	printk("%s(%d)\n", __func__, __LINE__);
+	AICWFDBG(LOGINFO, "%s(%d)\n", __func__, __LINE__);
 	return 0;
 }
 
 static int rwnx_disable_hostwake_irq(void)
 {
-	printk("%s(%d)\n", __func__, __LINE__);
+	AICWFDBG(LOGINFO, "%s(%d)\n", __func__, __LINE__);
 #ifdef CONFIG_GPIO_WAKEUP
 	disable_irq_nosync(hostwake_irq_num);
 	//disable_irq_wake(hostwake_irq_num);
@@ -526,9 +535,17 @@ static int aicwf_sdio_probe(struct sdio_func *func,
 
 	err = aicwf_sdio_chipmatch(sdiodev, func->vendor, func->device);
 
+#ifdef CONFIG_OOB
+    if(sdiodev->chipid == PRODUCT_ID_AIC8801){
+        AICWFDBG(LOGERROR, "%s ERROR!!! 8801 not support OOB \r\n", __func__);
+        goto fail;
+    }
+#endif //CONFIG_OOB
 
 	sdiodev->func = func;
 	sdiodev->bus_if = bus_if;
+	sdiodev->oob_enable = false;
+    atomic_set(&sdiodev->is_bus_suspend, 0);
 	bus_if->bus_priv.sdio = sdiodev;
 
 	dev_set_drvdata(&func->dev, bus_if);
@@ -560,11 +577,28 @@ static int aicwf_sdio_probe(struct sdio_func *func,
 		return err;
 
 #ifdef CONFIG_GPIO_WAKEUP
-	rwnx_send_me_set_lp_level(sdiodev->rwnx_hw, 1);
+#ifdef CONFIG_OOB
+    AICWFDBG(LOGINFO, "%s SDIOWIFI_INTR_CONFIG_REG Disable\n", __func__);
+    sdio_claim_host(sdiodev->func);
+    //disable sdio interrupt    
+    err = aicwf_sdio_writeb(sdiodev, SDIOWIFI_INTR_CONFIG_REG, 0x0);
+    if (err < 0) {
+        sdio_err("reg:%d write failed!\n", SDIOWIFI_INTR_CONFIG_REG);
+    }    
+    sdio_release_irq(sdiodev->func);
+    sdio_release_host(sdiodev->func);
+#if 0//old oob feature
+    sdiodev->oob_enable = true;
+#else//new oob feature
+    sdiodev->oob_enable = false;
+#endif//old oob feature
+#endif
+
 #ifdef CONFIG_WIFI_SUSPEND_FOR_LINUX
 	rwnx_init_wifi_suspend_node();
 #endif//CONFIG_WIFI_SUSPEND_FOR_LINUX
 #endif//CONFIG_GPIO_WAKEUP
+    device_disable_async_suspend(sdiodev->dev);
 
 	return 0;
 fail:
@@ -576,6 +610,12 @@ static int aicwf_sdio_probe(struct sdio_func *func,
 	return err;
 }
 
+void aicwf_sdio_probe_(struct sdio_func *func,
+	const struct sdio_device_id *id){
+    aicwf_sdio_probe(func, NULL);
+}
+
+
 static void aicwf_sdio_remove(struct sdio_func *func)
 {
 	struct mmc_host *host;
@@ -594,10 +634,11 @@ static void aicwf_sdio_remove(struct sdio_func *func)
 	if (!sdiodev) {
 		return;
 	}
-	rwnx_unregister_hostwake_irq(sdiodev->dev);
+
 	sdiodev->bus_if->state = BUS_DOWN_ST;
 	aicwf_sdio_release(sdiodev);
 	aicwf_sdio_func_deinit(sdiodev);
+	rwnx_unregister_hostwake_irq(sdiodev->dev);
 	dev_set_drvdata(&sdiodev->func->dev, NULL);
 	kfree(sdiodev);
 	kfree(bus_if);
@@ -607,6 +648,10 @@ static void aicwf_sdio_remove(struct sdio_func *func)
 	AICWFDBG(LOGINFO, "%s done\n", __func__);
 }
 
+void aicwf_sdio_remove_(struct sdio_func *func){
+    aicwf_sdio_remove(func);
+}
+
 static int aicwf_sdio_suspend(struct device *dev)
 {
 	int ret = 0;
@@ -631,7 +676,7 @@ static int aicwf_sdio_suspend(struct device *dev)
 		return ret;
 	}
 
-#if 1
+
 	while (sdiodev->state == SDIO_ACTIVE_ST) {
 		if (down_interruptible(&sdiodev->tx_priv->txctl_sema))
 			continue;
@@ -642,8 +687,7 @@ static int aicwf_sdio_suspend(struct device *dev)
 		break;
 	}
 #ifdef CONFIG_GPIO_WAKEUP
-	rwnx_enable_hostwake_irq();
-#endif
+//	rwnx_enable_hostwake_irq();
 #endif
 #if 0
 	sdio_dbg("%s SDIOWIFI_INTR_CONFIG_REG Disable\n", __func__);
@@ -656,6 +700,9 @@ static int aicwf_sdio_suspend(struct device *dev)
 	sdio_release_irq(sdiodev->func);
 	sdio_release_host(sdiodev->func);
 #endif
+    atomic_set(&sdiodev->is_bus_suspend, 1);
+//    smp_mb();
+
 	sdio_dbg("%s exit\n", __func__);
 
 	return 0;
@@ -669,9 +716,9 @@ static int aicwf_sdio_resume(struct device *dev)
 	//int ret;
 
 	sdio_dbg("%s enter \n", __func__);
-#ifdef CONFIG_GPIO_WAKEUP
-	rwnx_disable_hostwake_irq();
-#endif
+//#ifdef CONFIG_GPIO_WAKEUP
+//	rwnx_disable_hostwake_irq();
+//#endif
 	//dev_pm_clear_wake_irq(dev);
 	list_for_each_entry_safe(rwnx_vif, tmp, &sdiodev->rwnx_hw->vifs, list) {
 		if (rwnx_vif->ndev)
@@ -681,12 +728,13 @@ static int aicwf_sdio_resume(struct device *dev)
 	#if defined(CONFIG_SDIO_PWRCTRL)
 	aicwf_sdio_pwr_stctl(sdiodev, SDIO_ACTIVE_ST);
 	#endif
+
 	#ifdef CONFIG_WIFI_SUSPEND_FOR_LINUX
 	rwnx_set_wifi_suspend('0');
 	#endif//CONFIG_WIFI_SUSPEND_FOR_LINUX
 
 
-	aicwf_sdio_hal_irqhandler(sdiodev->func);
+//	aicwf_sdio_hal_irqhandler(sdiodev->func);
 
 #if 0
 	sdio_dbg("%s SDIOWIFI_INTR_CONFIG_REG Enable\n", __func__);
@@ -699,7 +747,8 @@ static int aicwf_sdio_resume(struct device *dev)
 		sdio_err("intr register failed:%d\n", ret);
 	sdio_release_host(sdiodev->func);
 #endif
-
+    atomic_set(&sdiodev->is_bus_suspend, 0);
+//    smp_mb();
 
 	sdio_dbg("%s exit\n", __func__);
 	return 0;
@@ -718,6 +767,7 @@ static const struct dev_pm_ops aicwf_sdio_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(aicwf_sdio_suspend, aicwf_sdio_resume)
 };
 
+#ifndef CONFIG_FDRV_NO_REG_SDIO
 static struct sdio_driver aicwf_sdio_driver = {
 	.probe = aicwf_sdio_probe,
 	.remove = aicwf_sdio_remove,
@@ -727,6 +777,7 @@ static struct sdio_driver aicwf_sdio_driver = {
 		.pm = &aicwf_sdio_pm_ops,
 	},
 };
+#endif
 
 #if 0
 #ifdef CONFIG_NANOPI_M4
@@ -738,6 +789,12 @@ extern void mmc_release_host(struct mmc_host *host);
 #endif
 #endif
 
+#ifdef CONFIG_FDRV_NO_REG_SDIO
+extern struct sdio_func *get_sdio_func(void);
+void aicwf_sdio_probe_(struct sdio_func *func, const struct sdio_device_id *id);
+void aicwf_sdio_remove_(struct sdio_func *func);
+#endif
+
 void aicwf_sdio_register(void)
 {
 #if 0
@@ -772,11 +829,16 @@ void aicwf_sdio_register(void)
 #endif
 #endif
 
+
+#ifndef CONFIG_FDRV_NO_REG_SDIO
 	if (sdio_register_driver(&aicwf_sdio_driver)) {
 
 	} else {
 		//may add mmc_rescan here
 	}
+#else
+    aicwf_sdio_probe_(get_sdio_func(), NULL);
+#endif
 }
 
 void aicwf_sdio_exit(void)
@@ -788,7 +850,12 @@ void aicwf_sdio_exit(void)
 	}
 
     udelay(500);
+
+#ifndef CONFIG_FDRV_NO_REG_SDIO  
 	sdio_unregister_driver(&aicwf_sdio_driver);
+#else
+    aicwf_sdio_remove_(get_sdio_func());
+#endif
 
 #if 0
 #ifdef CONFIG_PLATFORM_AMLOGIC
@@ -827,9 +894,9 @@ int aicwf_sdio_wakeup(struct aic_sdio_dev *sdiodev)
     }
 
 	if (sdiodev->state == SDIO_SLEEP_ST) {
-		sdio_info("%s w\n", __func__);
+		AICWFDBG(LOGSDPWRC, "%s w\n", __func__);
 
-		rwnx_pm_stay_awake(sdiodev);
+		//rwnx_pm_stay_awake(sdiodev);
 
 		while (write_retry) {
 			ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, wakeup_reg_val);
@@ -881,17 +948,17 @@ int aicwf_sdio_sleep_allow(struct aic_sdio_dev *sdiodev)
 	sdio_info("sleep: %d, %d\n", sdiodev->state, scanning);
 	if (sdiodev->state == SDIO_ACTIVE_ST  && !scanning && !rwnx_hw->is_p2p_alive \
 				&& !rwnx_hw->is_p2p_connected) {
-		sdio_info("%s s\n", __func__);
+		AICWFDBG(LOGSDPWRC, "%s s\n", __func__);
 		ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.sleep_reg, 0x10);
 		if (ret)
 			sdio_err("Write sleep fail!\n");
 		sdiodev->state = SDIO_SLEEP_ST;
 		aicwf_sdio_pwrctl_timer(sdiodev, 0);
+        //rwnx_pm_relax(sdiodev);
 	} else {
 		aicwf_sdio_pwrctl_timer(sdiodev, sdiodev->active_duration);
 	}
 
-	rwnx_pm_relax(sdiodev);
 	return ret;
 }
 
@@ -1358,8 +1425,8 @@ int aicwf_sdio_aggr(struct aicwf_tx_priv *tx_priv, struct sk_buff *pkt)
 	int allign_len = 0;
 	int headroom;
 
-	sdio_header[0] = ((pkt->len - sizeof(struct rwnx_txhdr) + sizeof(struct txdesc_api)) & 0xff);
-	sdio_header[1] = (((pkt->len - sizeof(struct rwnx_txhdr) + sizeof(struct txdesc_api)) >> 8)&0x0f);
+	sdio_header[0] = ((pkt->len - txhdr->sw_hdr->headroom + sizeof(struct txdesc_api)) & 0xff);
+	sdio_header[1] = (((pkt->len - txhdr->sw_hdr->headroom + sizeof(struct txdesc_api)) >> 8)&0x0f);
 	sdio_header[2] = 0x01; //data
 	if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8801 || 
         tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
@@ -1433,6 +1500,8 @@ void aicwf_sdio_aggrbuf_reset(struct aicwf_tx_priv *tx_priv)
 	atomic_set(&tx_priv->aggr_count, 0);
 }
 
+extern void set_irq_handler(void *fn);
+
 static int aicwf_sdio_bus_start(struct device *dev)
 {
 	struct aicwf_bus *bus_if = dev_get_drvdata(dev);
@@ -1441,8 +1510,11 @@ static int aicwf_sdio_bus_start(struct device *dev)
 
 
 	sdio_claim_host(sdiodev->func);
+#ifndef CONFIG_FDRV_NO_REG_SDIO
 	sdio_claim_irq(sdiodev->func, aicwf_sdio_hal_irqhandler);
-
+#else
+    set_irq_handler(aicwf_sdio_hal_irqhandler);  
+#endif
     if(sdiodev->chipid == PRODUCT_ID_AIC8800D80){
         sdio_f0_writeb(sdiodev->func, 0x07, 0x04, &ret);
         if (ret) {
@@ -1451,6 +1523,7 @@ static int aicwf_sdio_bus_start(struct device *dev)
     }
     sdio_release_host(sdiodev->func);
 
+
 	//enable sdio interrupt
 	ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x07);
 	if (ret != 0)
@@ -1479,72 +1552,255 @@ module_param_named(busrx_thread_prio, busrx_thread_prio, int, 0644);
 //module_param(busrx_thread_prio, int, 0);
 #endif
 
+#ifdef CONFIG_OOB
+int rx_thread_wait_to = 1000;
+module_param_named(rx_thread_wait_to, rx_thread_wait_to, int, 0644);
+
+//new oob feature
+int sdio_busirq_thread(void *data){
+        struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
+        struct aicwf_bus *bus_if = rx_priv->sdiodev->bus_if;
+#if 0    
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+        int set_cpu_ret = 0;
+       
+        AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+        set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(0));
+        AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+        AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
+
+#ifdef CONFIG_TXRX_THREAD_PRIO
+        if (busrx_thread_prio > 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+            sched_set_fifo_low(current);
+#else
+            struct sched_param param;
+            param.sched_priority = (busrx_thread_prio - 1 < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+            sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
+        }
+#endif
+
+        AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
+        AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+        AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
+    
+    
+    while (1) {
+            if (kthread_should_stop()) {
+                AICWFDBG(LOGERROR, "sdio busirq thread stop\n");
+                break;
+            }
+
+            if(!wait_for_completion_timeout(&bus_if->busirq_trgg, msecs_to_jiffies(rx_thread_wait_to))){
+                AICWFDBG(LOGRXPOLL, "%s wait for completion timout \r\n", __func__);
+            }
+       
+            if (bus_if->state == BUS_DOWN_ST)
+                continue;
+#if 1
+#ifdef CONFIG_SDIO_PWRCTRL
+            while(atomic_read(&bus_if->bus_priv.sdio->is_bus_suspend) == 1){
+                AICWFDBG(LOGDEBUG, "%s waiting for sdio bus resume \r\n", __func__);
+                msleep(100);
+            }
+            aicwf_sdio_pwr_stctl(bus_if->bus_priv.sdio, SDIO_ACTIVE_ST);
+#endif//CONFIG_SDIO_PWRCTRL
+#endif
+            aicwf_sdio_hal_irqhandler(bus_if->bus_priv.sdio->func);
+        }
+
+    return 0;
+}
+
+#endif//CONFIG_OOB
+
+#if 0
+#include <linux/sched.h>
+#endif
 int sdio_bustx_thread(void *data)
 {
 	struct aicwf_bus *bus = (struct aicwf_bus *) data;
 	struct aic_sdio_dev *sdiodev = bus->bus_priv.sdio;
+#if 0    
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    int set_cpu_ret = 0;
+
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
 
+#if 0
+	struct cpumask cpumask;
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(1, &cpumask);
+	cpumask_set_cpu(2, &cpumask);
+	cpumask_set_cpu(3, &cpumask);
+	sched_setaffinity(0, &cpumask);//need to add EXPORT_SYMBOL_GPL(sched_setaffinity) in kernel/sched/core.c
+#endif
 #ifdef CONFIG_TXRX_THREAD_PRIO
 		if (bustx_thread_prio > 0) {
-				struct sched_param param;
-				param.sched_priority = (bustx_thread_prio < MAX_RT_PRIO)?bustx_thread_prio:(MAX_RT_PRIO-1);
-				sched_setscheduler(current, SCHED_FIFO, &param);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+            sched_set_fifo_low(current);
+#else
+            struct sched_param param;
+            param.sched_priority = (bustx_thread_prio < MAX_RT_PRIO)?bustx_thread_prio:(MAX_RT_PRIO-1);
+            sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
 		}
 #endif
 
+    AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
+    AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+    AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
 
 	while (1) {
 		if (kthread_should_stop()) {
 			AICWFDBG(LOGERROR, "sdio bustx thread stop\n");
 			break;
 		}
-	if (!wait_for_completion_interruptible(&bus->bustx_trgg)) {
+        
+	    if (!wait_for_completion_interruptible(&bus->bustx_trgg)) {
 			if (sdiodev->bus_if->state == BUS_DOWN_ST)
 				continue;
+
+            rwnx_wakeup_lock(sdiodev->rwnx_hw->ws_tx);
 			if ((int)(atomic_read(&sdiodev->tx_priv->tx_pktcnt) > 0) || (sdiodev->tx_priv->cmd_txstate == true)){
-				rwnx_pm_stay_awake(sdiodev);
 				aicwf_sdio_tx_process(sdiodev);
-				rwnx_pm_relax(sdiodev);
 			}
+            rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_tx);
 		}
 	}
 
 	return 0;
 }
 
-
+#if 0//old oob feature
 int sdio_busrx_thread(void *data)
 {
-	struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
-	struct aicwf_bus *bus_if = rx_priv->sdiodev->bus_if;
-
+    struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
+    struct aicwf_bus *bus_if = rx_priv->sdiodev->bus_if;
+#if 0
+	struct cpumask cpumask;
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(1, &cpumask);
+	cpumask_set_cpu(2, &cpumask);
+	cpumask_set_cpu(3, &cpumask);
+	sched_setaffinity(0, &cpumask);
+#endif
 #ifdef CONFIG_TXRX_THREAD_PRIO
-		if (busrx_thread_prio > 0) {
-				struct sched_param param;
-				param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
-				sched_setscheduler(current, SCHED_FIFO, &param);
-		}
+    if (busrx_thread_prio > 0) {
+            struct sched_param param;
+            param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+            sched_setscheduler(current, SCHED_FIFO, &param);
+    }
 #endif
+    
+    AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
+    AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+    AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
+    
+while (1) {
+    if (kthread_should_stop()) {
+        AICWFDBG(LOGERROR, "sdio busrx thread stop\n");
+        break;
+    }
+#ifndef CONFIG_OOB
+        if (!wait_for_completion_interruptible(&bus_if->busrx_trgg)) {
+#else
+        if(!wait_for_completion_timeout(&bus_if->busrx_trgg, msecs_to_jiffies(rx_thread_wait_to))){
+            AICWFDBG(LOGDEBUG, "%s wait for completion timout \r\n", __func__);
+        }
+#endif
+        if (bus_if->state == BUS_DOWN_ST)
+            continue;
+#ifdef CONFIG_OOB
+#ifdef CONFIG_SDIO_PWRCTRL
+        while(atomic_read(&bus_if->bus_priv.sdio->is_bus_suspend) == 1){
+            AICWFDBG(LOGDEBUG, "%s waiting for sdio bus resume \r\n", __func__);
+            msleep(100);
+        }
+        aicwf_sdio_pwr_stctl(bus_if->bus_priv.sdio, SDIO_ACTIVE_ST);
+#endif//CONFIG_SDIO_PWRCTRL
+        aicwf_sdio_hal_irqhandler(bus_if->bus_priv.sdio->func);
+#endif//CONFIG_OOB
+        rwnx_wakeup_lock(rx_priv->sdiodev->rwnx_hw->ws_rx);
+        aicwf_process_rxframes(rx_priv);
+        rwnx_wakeup_unlock(rx_priv->sdiodev->rwnx_hw->ws_rx);
+#ifndef CONFIG_OOB
+        }
+#endif
+    }
+    
+    return 0;
 
+}
+#else//new oob feature
+int sdio_busrx_thread(void *data)
+{
+    struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
+    struct aicwf_bus *bus_if = rx_priv->sdiodev->bus_if;
+    
+    
+#if 0
+	struct cpumask cpumask;
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(1, &cpumask);
+	cpumask_set_cpu(2, &cpumask);
+	cpumask_set_cpu(3, &cpumask);
+	sched_setaffinity(0, &cpumask);
+#endif
 
-	while (1) {
-		if (kthread_should_stop()) {
-			AICWFDBG(LOGERROR, "sdio busrx thread stop\n");
-			break;
-		}
-		if (!wait_for_completion_interruptible(&bus_if->busrx_trgg)) {
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    int set_cpu_ret = 0;
 
-			if (bus_if->state == BUS_DOWN_ST)
-				continue;
-			rwnx_pm_stay_awake(rx_priv->sdiodev);
-			aicwf_process_rxframes(rx_priv);
-			rwnx_pm_relax(rx_priv->sdiodev);
-		}
-	}
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(2));
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+
+#ifdef CONFIG_TXRX_THREAD_PRIO
+    if (busrx_thread_prio > 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+        sched_set_fifo_low(current);
+#else
+        struct sched_param param;
+        param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+        sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
+    }
+#endif
+    
+    AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
+    AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+    AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
+    
+    while (1) {
+        if (kthread_should_stop()) {
+            AICWFDBG(LOGERROR, "sdio busrx thread stop\n");
+            break;
+        }
+        if (!wait_for_completion_interruptible(&bus_if->busrx_trgg)) {
+
+            if (bus_if->state == BUS_DOWN_ST)
+                continue;
+            rwnx_wakeup_lock(rx_priv->sdiodev->rwnx_hw->ws_rx);
+            aicwf_process_rxframes(rx_priv);
+            rwnx_wakeup_unlock(rx_priv->sdiodev->rwnx_hw->ws_rx);
+        }
+    }
+    return 0;
 
-	return 0;
 }
 
+#endif//old oob feature
+
 #if defined(CONFIG_SDIO_PWRCTRL)
 static int aicwf_sdio_pwrctl_thread(void *data)
 {
@@ -1560,11 +1816,16 @@ static int aicwf_sdio_pwrctl_thread(void *data)
 
 			if (sdiodev->bus_if->state == BUS_DOWN_ST)
 				continue;
+
+            rwnx_wakeup_lock(sdiodev->rwnx_hw->ws_pwrctrl);
+            
 			if ((int)(atomic_read(&sdiodev->tx_priv->tx_pktcnt) <= 0) && (sdiodev->tx_priv->cmd_txstate == false) && \
 					atomic_read(&sdiodev->rx_priv->rx_cnt) == 0)
 				aicwf_sdio_pwr_stctl(sdiodev, SDIO_SLEEP_ST);
 			else
 				aicwf_sdio_pwrctl_timer(sdiodev, sdiodev->active_duration);
+
+            rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_pwrctrl);
 		}
 	}
 
@@ -1639,19 +1900,13 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
 	#endif
 	int ret;
 
-	//printk("%s enter \r\n", __func__);
-
-	if ((int)(atomic_read(&sdiodev->irq_sdio_atomic)) > 0){
-		printk("%s conflict return it\r\n", __func__);
-		return;
-	}else{
-		atomic_inc(&sdiodev->irq_sdio_atomic);
-	}
+	//AICWFDBG(LOGDEBUG, "fdrv %s enter \r\n", __func__);
+    rwnx_wakeup_lock(sdiodev->rwnx_hw->ws_irqrx);
 
 
 	if (!bus_if || bus_if->state == BUS_DOWN_ST) {
 		sdio_err("bus err\n");
-		atomic_dec(&sdiodev->irq_sdio_atomic);
+        rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_irqrx);
 		return;
 	}
 
@@ -1660,6 +1915,7 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
     	#ifdef CONFIG_PREALLOC_RX_SKB
     	if (list_empty(&aic_rx_buff_list.rxbuff_list)) {
             printk("%s %d, rxbuff list is empty\n", __func__, __LINE__);
+            rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_irqrx);
             return;
         }
     	#endif
@@ -1687,7 +1943,11 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
     	if (pkt)
     		aicwf_sdio_enq_rxpkt(sdiodev, pkt);
 
-    	complete(&bus_if->busrx_trgg);
+        if(atomic_read(&sdiodev->rx_priv->rx_cnt) == 1 && 
+            sdiodev->oob_enable == false){
+            complete(&bus_if->busrx_trgg);
+        }
+
     }else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
         do {
             ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.misc_int_status_reg, &intstatus);
@@ -1745,11 +2005,13 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
         if (pkt)
             aicwf_sdio_enq_rxpkt(sdiodev, pkt);
 
-        if(atomic_read(&sdiodev->rx_priv->rx_cnt) == 1)
+        if(atomic_read(&sdiodev->rx_priv->rx_cnt) == 1 && 
+            sdiodev->oob_enable == false){
             complete(&bus_if->busrx_trgg);
+        }
     }
 
-	atomic_dec(&sdiodev->irq_sdio_atomic);
+    rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_irqrx);
 }
 
 #if defined(CONFIG_SDIO_PWRCTRL)
@@ -1784,12 +2046,14 @@ static struct aicwf_bus_ops aicwf_sdio_bus_ops = {
 void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 {
 	struct aicwf_bus *bus_if;
-	int ret;
+#ifndef CONFIG_OOB
+    int ret;
+#endif
 	AICWFDBG(LOGINFO, "%s Enter\n", __func__);
 
 	bus_if = dev_get_drvdata(sdiodev->dev);
 	bus_if->state = BUS_DOWN_ST;
-
+#ifndef CONFIG_OOB
 	sdio_claim_host(sdiodev->func);
 	//disable sdio interrupt
     ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
@@ -1798,7 +2062,7 @@ void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 	}
 	sdio_release_irq(sdiodev->func);
 	sdio_release_host(sdiodev->func);
-
+#endif
 	if (sdiodev->dev)
 		aicwf_bus_deinit(sdiodev->dev);
 
@@ -1941,7 +2205,7 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 	u8 byte_mode_disable = 0x1;//1: no byte mode
 	int ret = 0;
 	struct aicbsp_feature_t feature;
-	u8 val = 0;
+	//u8 val = 0;
     u8 val1 = 0;
 
 	aicbsp_get_feature(&feature, NULL);
@@ -1951,12 +2215,27 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 
 	sdio_claim_host(sdiodev->func);
     sdiodev->func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+
+	ret = sdio_set_block_size(sdiodev->func, SDIOWIFI_FUNC_BLOCKSIZE);
+	if (ret < 0) {
+		AICWFDBG(LOGERROR, "set blocksize fail %d\n", ret);
+		sdio_release_host(sdiodev->func);
+		return ret;
+	}
+	ret = sdio_enable_func(sdiodev->func);
+	if (ret < 0) {
+		sdio_release_host(sdiodev->func);
+		AICWFDBG(LOGERROR, "enable func fail %d.\n", ret);
+        return ret;
+	}
+
     sdio_f0_writeb(sdiodev->func, 0x7F, 0xF2, &ret);
     if (ret) {
         sdio_err("set fn0 0xF2 fail %d\n", ret);
         sdio_release_host(sdiodev->func);
         return ret;
     }
+#if 0
     if (host->ios.timing == MMC_TIMING_UHS_DDR50) {
         val = 0x21;//0x1D;//0x5;
     } else {
@@ -1981,7 +2260,7 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
         sdio_release_host(sdiodev->func);
         return ret;
     }
-    udelay(100);
+    msleep(1);
 #if 1//SDIO CLOCK SETTING
 	if ((feature.sdio_clock > 0) && (host->ios.timing != MMC_TIMING_UHS_DDR50)) {
 		host->ios.clock = feature.sdio_clock;
@@ -1989,20 +2268,7 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 		AICWFDBG(LOGINFO, "Set SDIO Clock %d MHz\n", host->ios.clock/1000000);
 	}
 #endif
-
-	ret = sdio_set_block_size(sdiodev->func, SDIOWIFI_FUNC_BLOCKSIZE);
-	if (ret < 0) {
-		AICWFDBG(LOGERROR, "set blocksize fail %d\n", ret);
-		sdio_release_host(sdiodev->func);
-		return ret;
-	}
-	ret = sdio_enable_func(sdiodev->func);
-	if (ret < 0) {
-		sdio_release_host(sdiodev->func);
-		AICWFDBG(LOGERROR, "enable func fail %d.\n", ret);
-        return ret;
-	}
-
+#endif
 	sdio_release_host(sdiodev->func);
 
 	//1: no byte mode
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
old mode 100755
new mode 100644
index 7abb0d660..19ec8472d
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
@@ -123,8 +123,9 @@ struct aic_sdio_dev {
 	u16 chipid;
     struct aic_sdio_reg sdio_reg;
 
-	atomic_t irq_sdio_atomic;//AIDEN test
 	spinlock_t wslock;//AIDEN test
+	bool oob_enable;
+    atomic_t is_bus_suspend;
 };
 extern struct aicwf_rx_buff_list aic_rx_buff_list;
 int aicwf_sdio_writeb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 val);
@@ -153,6 +154,10 @@ void aicwf_sdio_register(void);
 int aicwf_sdio_txpkt(struct aic_sdio_dev *sdiodev, struct sk_buff *pkt);
 int sdio_bustx_thread(void *data);
 int sdio_busrx_thread(void *data);
+#ifdef CONFIG_OOB
+//new oob feature
+int sdio_busirq_thread(void *data);
+#endif //CONFIG_OOB
 int aicwf_sdio_aggr(struct aicwf_tx_priv *tx_priv, struct sk_buff *pkt);
 int aicwf_sdio_send(struct aicwf_tx_priv *tx_priv, u8 txnow);
 void aicwf_sdio_aggr_send(struct aicwf_tx_priv *tx_priv);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
old mode 100755
new mode 100644
index 3895a433a..7f8c7d924
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -26,6 +26,7 @@
 #ifdef AICWF_SDIO_SUPPORT
 #include "sdio_host.h"
 #endif
+#include "aic_bsp_export.h"
 
 #ifdef CONFIG_PREALLOC_RX_SKB
 void aicwf_rxframe_queue_init_2(struct rx_frame_queue *pq, int max_len)
@@ -91,11 +92,16 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 
 	init_completion(&bus_if->bustx_trgg);
 	init_completion(&bus_if->busrx_trgg);
+    //new oob feature
+    init_completion(&bus_if->busirq_trgg);
 #ifdef AICWF_SDIO_SUPPORT
 	spin_lock_init(&bus_if->bus_priv.sdio->wslock);//AIDEN test
-	atomic_set(&bus_if->bus_priv.sdio->irq_sdio_atomic, 0);//AIDEN test
 	bus_if->bustx_thread = kthread_run(sdio_bustx_thread, (void *)bus_if, "aicwf_bustx_thread");
 	bus_if->busrx_thread = kthread_run(sdio_busrx_thread, (void *)bus_if->bus_priv.sdio->rx_priv, "aicwf_busrx_thread");
+    //new oob feature
+#ifdef CONFIG_OOB
+    bus_if->busirq_thread = kthread_run(sdio_busirq_thread, (void *)bus_if->bus_priv.sdio->rx_priv, "aicwf_busirq_thread");
+#endif //CONFIG_OOB
 #endif
 #ifdef AICWF_USB_SUPPORT
 	bus_if->bustx_thread = kthread_run(usb_bustx_thread, (void *)bus_if, "aicwf_bustx_thread");
@@ -197,7 +203,11 @@ struct aicwf_tx_priv *aicwf_tx_init(void *arg)
 #endif
 
 	atomic_set(&tx_priv->aggr_count, 0);
+#if AICBSP_RESV_MEM_SUPPORT
+	tx_priv->aggr_buf = aicbsp_resv_mem_alloc_skb(MAX_AGGR_TXPKT_LEN, AIC_RESV_MEM_TXDATA);
+#else
 	tx_priv->aggr_buf = dev_alloc_skb(MAX_AGGR_TXPKT_LEN);
+#endif
 	if (!tx_priv->aggr_buf) {
 		txrx_err("Alloc bus->txdata_buf failed!\n");
 		kfree(tx_priv);
@@ -212,7 +222,11 @@ struct aicwf_tx_priv *aicwf_tx_init(void *arg)
 void aicwf_tx_deinit(struct aicwf_tx_priv *tx_priv)
 {
 	if (tx_priv && tx_priv->aggr_buf) {
+#if AICBSP_RESV_MEM_SUPPORT
+		aicbsp_resv_mem_kfree_skb(tx_priv->aggr_buf, AIC_RESV_MEM_TXDATA);
+#else
 		dev_kfree_skb(tx_priv->aggr_buf);
+#endif
 		kfree(tx_priv);
 	}
 }
@@ -598,6 +612,14 @@ void aicwf_rx_deinit(struct aicwf_rx_priv *rx_priv)
 		kthread_stop(rx_priv->sdiodev->bus_if->busrx_thread);
 		rx_priv->sdiodev->bus_if->busrx_thread = NULL;
 	}
+#ifdef CONFIG_OOB
+    //new oob feature
+    if (rx_priv->sdiodev->bus_if->busirq_thread) {
+        complete_all(&rx_priv->sdiodev->bus_if->busirq_trgg);
+        kthread_stop(rx_priv->sdiodev->bus_if->busirq_thread);
+        rx_priv->sdiodev->bus_if->busirq_thread = NULL;
+    }
+#endif //CONFIG_OOB
 #endif
 #ifdef AICWF_USB_SUPPORT
 	if (rx_priv->usbdev->bus_if->busrx_thread) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
old mode 100755
new mode 100644
index a36bfbdb1..393fb5dcc
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
@@ -97,8 +97,10 @@ struct aicwf_bus {
 	u8 *cmd_buf;
 	struct completion bustx_trgg;
 	struct completion busrx_trgg;
+        struct completion busirq_trgg;//new oob feature
 	struct task_struct *bustx_thread;
 	struct task_struct *busrx_thread;
+        struct task_struct *busirq_thread;//new oob feature
 };
 
 struct aicwf_tx_priv {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_compat.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_host.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h b/drivers/net/wireless/aic8800/aic8800_fdrv/ipc_shared.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
old mode 100755
new mode 100644
index 1501b1fdc..81740182e
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -377,14 +377,19 @@ enum mm_msg_tag {
 
     MM_APM_STALOSS_IND,
 
-    MM_SET_TXOP_REQ,
-    MM_SET_TXOP_CFM,
+    MM_SET_VENDOR_HWCONFIG_REQ,
+    MM_SET_VENDOR_HWCONFIG_CFM,
 
     MM_GET_FW_VERSION_REQ,
     MM_GET_FW_VERSION_CFM,
 
-    MM_SET_VENDOR_TRX_PARAM_REQ,
-    MM_SET_VENDOR_TRX_PARAM_CFM,
+    MM_SET_RESUME_RESTORE_REQ,
+    MM_SET_RESUME_RESTORE_CFM,
+
+    MM_GET_WIFI_DISABLE_REQ,
+    MM_GET_WIFI_DISABLE_CFM,
+
+    MM_CFG_RSSI_CFM,
 
     /// MAX number of messages
     MM_MAX,
@@ -1251,6 +1256,12 @@ typedef struct
     s8_l pwrlvl_11ax_5g[12];
 } txpwr_lvl_conf_v3_t;
 
+typedef struct
+{
+    u8_l loss_enable;
+    u8_l loss_value;
+} txpwr_loss_conf_t;
+
 struct mm_set_txpwr_lvl_req
 {
   union {
@@ -1289,6 +1300,13 @@ typedef struct {
 	s8_l chan_142_165;
 } txpwr_ofst_conf_t;
 
+typedef struct
+{
+    int8_t enable;
+    int8_t pwrofst2x_tbl_2g4[3][3];
+    int8_t pwrofst2x_tbl_5g[3][6];
+} txpwr_ofst2x_conf_t;
+
 typedef struct
 {
     u8_l enable;
@@ -1298,7 +1316,10 @@ typedef struct
 
 
 struct mm_set_txpwr_ofst_req {
-	txpwr_ofst_conf_t txpwr_ofst;
+	union {
+	  txpwr_ofst_conf_t txpwr_ofst;
+	  txpwr_ofst2x_conf_t txpwr_ofst2x;
+	};
 };
 
 struct mm_set_stack_start_req {
@@ -1792,6 +1813,70 @@ struct mm_apm_staloss_ind
         u8_l mac_addr[6];
 };
 
+enum vendor_hwconfig_tag{
+	ACS_TXOP_REQ = 0,
+	CHANNEL_ACCESS_REQ,
+	MAC_TIMESCALE_REQ,
+	CCA_THRESHOLD_REQ,
+	BWMODE_REQ,
+};
+
+enum {
+    BWMODE20M = 0,
+    BWMODE10M,
+    BWMODE5M,
+};
+
+struct mm_set_acs_txop_req
+{
+    u32_l hwconfig_id;
+	u16_l txop_bk;
+	u16_l txop_be;
+	u16_l txop_vi;
+	u16_l txop_vo;
+};
+
+struct mm_set_channel_access_req
+{
+    u32_l hwconfig_id;
+	u32_l edca[4];
+	u8_l  vif_idx;
+	u8_l  retry_cnt;
+	u8_l  rts_en;
+	u8_l  long_nav_en;
+	u8_l  cfe_en;
+	u8_l  rc_retry_cnt[3];
+};
+
+struct mm_set_mac_timescale_req
+{
+    u32_l hwconfig_id;
+	u8_l  sifsA_time;
+	u8_l  sifsB_time;
+	u8_l  slot_time;
+	u8_l  rx_startdelay_ofdm;
+	u8_l  rx_startdelay_long;
+	u8_l  rx_startdelay_short;
+};
+
+struct mm_set_cca_threshold_req
+{
+    u32_l hwconfig_id;
+	u8_l  auto_cca_en;
+	s8_l  cca20p_rise_th;
+	s8_l  cca20s_rise_th;
+	s8_l  cca20p_fall_th;
+	s8_l  cca20s_fall_th;
+
+};
+
+struct mm_set_bwmode_req
+{
+    u32_l hwconfig_id;
+    u8_l bwmode;
+};
+
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -1932,10 +2017,15 @@ enum sm_msg_tag {
 	/// Response to external authentication request
 	SM_EXTERNAL_AUTH_REQUIRED_RSP,
 	/// Request to update assoc elements after FT over the air authentication
-    SM_FT_AUTH_IND,
-    /// Response to FT authentication with updated assoc elements
-    SM_FT_AUTH_RSP,
+	SM_FT_AUTH_IND,
+	/// Response to FT authentication with updated assoc elements
+	SM_FT_AUTH_RSP,
+
+	SM_RSP_TIMEOUT_IND,
+
+	SM_COEX_TS_TIMEOUT_IND,
 
+	SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM,
 	/// MAX number of messages
 	SM_MAX,
 };
@@ -2560,7 +2650,7 @@ struct dbg_rftest_cmd_req {
 };
 
 struct dbg_rftest_cmd_cfm {
-	u32_l rftest_result[16];
+	u32_l rftest_result[18];
 };
 
 struct dbg_gpio_write_req {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/md5.c b/drivers/net/wireless/aic8800/aic8800_fdrv/md5.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/md5.h b/drivers/net/wireless/aic8800/aic8800_fdrv/md5.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_bfmer.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cfgfile.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
old mode 100755
new mode 100644
index 6addda4fa..36f4686ed
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -197,7 +197,9 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
 
 		kfree(cmd->a2e_msg);
 	} else {
-		WAKE_CMD_WORK(cmd_mgr);
+        if(cmd_mgr->queue_sz <= 1){
+		    WAKE_CMD_WORK(cmd_mgr);
+        }
 		return 0;
 	}
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
old mode 100755
new mode 100644
index a9a0ca01a..b757a65cf
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
@@ -24,7 +24,7 @@
 #ifdef AICWF_USB_SUPPORT
 #define RWNX_80211_CMD_TIMEOUT_MS    2000//300
 #else
-#define RWNX_80211_CMD_TIMEOUT_MS    2000//500//300
+#define RWNX_80211_CMD_TIMEOUT_MS    3000//500//300
 #endif
 #endif
 
@@ -39,7 +39,7 @@
 #define RWNX_CMD_WAIT_COMPLETE(flags) \
 	(!(flags & (RWNX_CMD_FLAG_WAIT_ACK | RWNX_CMD_FLAG_WAIT_CFM)))
 
-#define RWNX_CMD_MAX_QUEUED         8
+#define RWNX_CMD_MAX_QUEUED         16
 
 #ifdef CONFIG_RWNX_FHOST
 #include "ipc_fhost.h"
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
old mode 100755
new mode 100644
index 2d13ed3d1..000874b67
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
@@ -41,7 +41,7 @@
 #define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK IEEE80211_HE_MAC_CAP3_MAX_A_AMPDU_LEN_EXP_MASK
 #endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 60)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 0)
 #define IEEE80211_MAX_AMPDU_BUF IEEE80211_MAX_AMPDU_BUF_HE
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
old mode 100755
new mode 100644
index 4389d99c4..e04bbbb10
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -1255,6 +1255,82 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
 
 DEBUGFS_WRITE_FILE_OPS(regdbg);
 
+static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
+			const char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct rwnx_hw *priv = file->private_data;
+	char buf[64];
+	int32_t addr[12];
+	u32_l hwconfig_id;
+	size_t len = min_t(size_t,count,sizeof(buf)-1);
+	int ret;
+    printk("%s\n",__func__);
+	//choose the type of write info by struct
+	//struct mm_set_vendor_trx_param_req trx_param;
+
+	if(copy_from_user(buf,user_buf,len)) {
+		return -EFAULT;
+	}
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x",
+                            &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11]);
+	if(ret > 13) {
+		printk("param error > 13\n");
+	} else {
+		switch(hwconfig_id)
+		    {
+		    case 0:
+			if(ret != 5) {
+			    printk("param error  != 5\n");
+			    break;}
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			printk("ACS_TXOP_REQ bk:0x%x be:0x%x vi:0x%x vo:0x%x\n",addr[0],  addr[1], addr[2], addr[3]);
+			break;
+		    case 1:
+			if(ret != 13) {
+			    printk("param error  != 13\n");
+			    break;}
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11]);
+			break;
+		    case 2:
+			if(ret != 7) {
+		            printk("param error  != 7\n");
+			    break;}
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			printk("MAC_TIMESCALE_REQ sifsA:%x,sifsB:%x,slot:%x,ofdm_delay:%x,long_delay:%x,short_delay:%x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5]);
+			break;
+		    case 3:
+                        if(ret != 6) {
+		            printk("param error  != 6\n");
+			    break;}
+			addr[1] = ~addr[1] + 1;
+			addr[2] = ~addr[2] + 1;
+			addr[3] = ~addr[3] + 1;
+			addr[4] = ~addr[4] + 1;
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			printk("CCA_THRESHOLD_REQ auto_cca:%d, cca20p_rise:%d cca20s_rise:%d cca20p_fail:%d cca20s_fail:%d\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4]);
+			break;
+		    default:
+			printk("param error\n");
+			break;
+		}
+		if(ret) {
+		    printk("rwnx_send_vendor_hwconfig_req fail: %x\n", ret);
+		}
+	}
+
+	return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig)
+
+
 #ifdef CONFIG_RWNX_FULLMAC
 
 #define LINE_MAX_SZ 150
@@ -1645,10 +1721,11 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
     struct rwnx_sta *sta = NULL;
     struct rwnx_hw *priv = file->private_data;
     u8 mac[6];
-    char buf[10];
+    char buf[20];
     int fixed_rate_idx = 1;
 	unsigned int formatmod, mcs, nss, bwTx, gi;
     union rwnx_rate_ctrl_info rate_config;
+	union rwnx_rate_ctrl_info *r_cfg=&rate_config;
     int error = 0;
     size_t len = min_t(size_t, count, sizeof(buf) - 1);
 
@@ -1657,8 +1734,8 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
     /* Get the station index from MAC address */
     sscanf(file->f_path.dentry->d_parent->d_iname, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
             &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
-    if (mac == NULL)
-        return 0;
+    //if (mac == NULL)
+    //    return 0;
     sta = rwnx_get_sta(priv, mac);
     if (sta == NULL)
         return 0;
@@ -1669,7 +1746,13 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
     buf[len] = '\0';
     //sscanf(buf, "%i\n", &fixed_rate_idx);
 	sscanf(buf, "%u %u %u %u %u",&formatmod, &mcs, &nss, &bwTx, &gi);
-	//printk("%u %u %u %u %u\n",formatmod, mcs, nss, bwTx, gi);
+	printk("%u %u %u %u %u\n",formatmod, mcs, nss, bwTx, gi);
+
+    if((formatmod > 6) || (mcs > 11) || (nss > 8) || (bwTx > 6) || (gi > 3)){
+        printk("error parameter");
+        return len;
+    }
+
     /* Convert rate index into rate configuration */
     if ((fixed_rate_idx < 0) || (fixed_rate_idx >= (N_CCK + N_OFDM + N_HT + N_VHT + N_HE_SU)))
     {
@@ -1681,9 +1764,8 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
         //idx_to_rate_cfg(fixed_rate_idx, &rate_config, NULL);
         idx_to_rate_cfg1(formatmod, mcs, nss, bwTx, gi, &rate_config, NULL);
     }
-	/*union rwnx_rate_ctrl_info *r_cfg=&rate_config;
+
 	printk("formatModTx=%u mcsIndexTx=%u bwTx=%u giAndPreTypeTx=%u\n",r_cfg->formatModTx,r_cfg->mcsIndexTx,r_cfg->bwTx,r_cfg->giAndPreTypeTx);
-	printk("you wen ti");*/
 	// Forward the request to the LMAC
     if ((error = rwnx_send_me_rc_set_rate(priv, sta->sta_idx,
                                           (u16)rate_config.value)) != 0)
@@ -1691,6 +1773,7 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
         return error;
     }
 
+	printk("send success \n");
     priv->debugfs.rc_config[sta->sta_idx] = (int)rate_config.value;
     return len;
 
@@ -2069,6 +2152,7 @@ int rwnx_dbgfs_register(struct rwnx_hw *rwnx_hw, const char *name)
 	DEBUGFS_ADD_FILE(mu_group, dir_drv, S_IRUSR);
 #endif
 	DEBUGFS_ADD_FILE(regdbg, dir_drv, S_IWUSR);
+	DEBUGFS_ADD_FILE(vendor_hwconfig, dir_drv,S_IWUSR);
 
 #ifdef CONFIG_RWNX_P2P_DEBUGFS
 	{
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
old mode 100755
new mode 100644
index 85cb973f9..7c49f3aee
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -594,6 +594,9 @@ struct rwnx_hw {
 #endif
 	struct rwnx_survey_info survey[SCAN_CHANNEL_MAX];
 	struct cfg80211_scan_request *scan_request;
+#ifdef CONFIG_SCHED_SCAN
+    struct cfg80211_sched_scan_request *sched_scan_req;
+#endif
 	struct rwnx_chanctx chanctx_table[NX_CHAN_CTXT_CNT];
 	u8 cur_chanctx;
 
@@ -633,7 +636,7 @@ struct rwnx_hw {
 	struct rwnx_ipc_dbgdump_elem dbgdump_elem;
 	struct rwnx_ipc_elem_pool e2arxdesc_pool;
 	struct rwnx_ipc_skb_elem *e2aunsuprxvec_elems;
-	struct rwnx_ipc_rxbuf_elems rxbuf_elems;
+	//struct rwnx_ipc_rxbuf_elems rxbuf_elems;
 	struct rwnx_ipc_elem_var scan_ie;
 
 	struct kmem_cache      *sw_txhdr_cache;
@@ -641,7 +644,12 @@ struct rwnx_hw {
 	struct rwnx_debugfs     debugfs;
 	struct rwnx_stats       stats;
 
-	struct rwnx_txq txq[NX_NB_TXQ];
+#ifdef CONFIG_PREALLOC_TXQ
+    struct rwnx_txq *txq;
+#else
+    struct rwnx_txq txq[NX_NB_TXQ];
+#endif
+
 	struct rwnx_hwq hwq[NX_TXQ_CNT];
 
 	u8 avail_idx_map;
@@ -673,6 +681,15 @@ struct rwnx_hw {
     struct workqueue_struct *apmStaloss_wq;
     u8 apm_vif_idx;
     u8 sta_mac_addr[6];
+
+    struct wakeup_source *ws_rx;
+    struct wakeup_source *ws_irqrx;
+    struct wakeup_source *ws_tx;
+    struct wakeup_source *ws_pwrctrl;
+
+#ifdef CONFIG_SCHED_SCAN
+    bool is_sched_scan;
+#endif//CONFIG_SCHED_SCAN 
 };
 
 u8 *rwnx_build_bcn(struct rwnx_bcn *bcn, struct cfg80211_beacon_data *new);
@@ -686,7 +703,7 @@ extern u8 chip_id;
 
 static inline bool is_multicast_sta(int sta_idx)
 {
-    if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) ||
+    if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) ||
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3))
         {
             return (sta_idx >= NX_REMOTE_STA_MAX_FOR_OLD_IC);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_dini.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_events.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_fw_trace.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_gki.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_irqs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
old mode 100755
new mode 100644
index 8e0f3e715..e7b4e7ee7
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -50,6 +50,7 @@
 #include "aic_bsp_export.h"
 #include "aicwf_compat_8800dc.h"
 #include "aicwf_compat_8800d80.h"
+#include "rwnx_wakelock.h"
 
 
 #define RW_DRV_DESCRIPTION  "RivieraWaves 11nac driver for Linux cfg80211"
@@ -501,8 +502,7 @@ static const int rwnx_hwq2uapsd[NL80211_NUM_ACS] = {
 
 
 extern uint8_t scanning;
-//int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
-int aicwf_dbg_level = LOGERROR;
+int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
 module_param(aicwf_dbg_level, int, 0660);
 int testmode = 0;
 char aic_fw_path[200];
@@ -532,7 +532,7 @@ struct rwnx_sta *rwnx_get_sta(struct rwnx_hw *rwnx_hw, const u8 *mac_addr)
 
 void rwnx_enable_wapi(struct rwnx_hw *rwnx_hw)
 {
-	cipher_suites[rwnx_hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_SMS4;
+	//cipher_suites[rwnx_hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_SMS4;
 	rwnx_hw->wiphy->n_cipher_suites++;
 	rwnx_hw->wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;
 }
@@ -773,7 +773,13 @@ static void rwnx_csa_finish(struct work_struct *ws)
 		} else
 			rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
 		spin_unlock_bh(&rwnx_hw->cb_lock);
-		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 94))
+                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
+                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
+#else
+                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
+#endif
 		mutex_unlock(&vif->wdev.mtx);
 		__release(&vif->wdev.mtx);
 	}
@@ -917,18 +923,28 @@ static int rwnx_open(struct net_device *dev)
 	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
 	struct mm_add_if_cfm add_if_cfm;
 	int error = 0;
+    u8 rwnx_rx_gain = 0x0E;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 #ifdef CONFIG_GPIO_WAKEUP
 //close lp mode
-	rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 0);
+//	rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 0);
 #endif//CONFIG_GPIO_WAKEUP
 
 	// Check if it is the first opened VIF
 	if (rwnx_hw->vif_started == 0) {
 		// Start the FW
 	   error = rwnx_send_start(rwnx_hw);
+       if (error)
+		  return error;
+
+       if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
+            error = rwnx_send_dbg_mem_mask_write_req(rwnx_hw, 0x4033b300, 0xFF, rwnx_rx_gain);
+            if(error){
+                return error;
+            }
+       }
 
 	   #ifdef CONFIG_COEX
 	   if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 ||
@@ -941,9 +957,6 @@ static int rwnx_open(struct net_device *dev)
 	   }
 	   #endif
 
-	   if (error)
-		   return error;
-
 	   /* Device is now started */
 	   set_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
 	   atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
@@ -967,6 +980,8 @@ static int rwnx_open(struct net_device *dev)
 		rwnx_vif->up = true;
 		rwnx_hw->vif_started++;
 		rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+        AICWFDBG(LOGDEBUG, "%s ap create vif in rwnx_hw->vif_table[%d] \r\n", 
+            __func__, rwnx_vif->vif_index);
 		spin_unlock_bh(&rwnx_hw->cb_lock);
 	} else {
 		/* Forward the information to the LMAC,
@@ -989,6 +1004,8 @@ static int rwnx_open(struct net_device *dev)
 		rwnx_vif->up = true;
 		rwnx_hw->vif_started++;
 		rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+        AICWFDBG(LOGDEBUG, "%s sta create vif in rwnx_hw->vif_table[%d] \r\n", 
+            __func__, rwnx_vif->vif_index);
 		spin_unlock_bh(&rwnx_hw->cb_lock);
 
 #ifdef CONFIG_USE_P2P0
@@ -1084,6 +1101,7 @@ static int rwnx_close(struct net_device *dev)
 	}
 
 	rwnx_vif->up = false;
+    AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
 
 	if (netif_carrier_ok(dev)) {
 		if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
@@ -1186,7 +1204,7 @@ static int rwnx_close(struct net_device *dev)
 
 #ifdef CONFIG_GPIO_WAKEUP
 	//open lp mode
-	rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1);
+	//rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1);
 #if defined(CONFIG_SDIO_PWRCTRL)
 		aicwf_sdio_pwr_stctl(g_rwnx_plat->sdiodev, SDIO_SLEEP_ST);
 #endif
@@ -1229,10 +1247,16 @@ enum {
 	RDWR_EFUSE_PWROFST,
 	RDWR_EFUSE_DRVIBIT,
 	SET_PAPR,
-    SET_COB_CAL,
-    GET_COB_CAL_RES,
-	SETSUSPENDMODE,
-
+	SET_CAL_XTAL,
+	GET_CAL_XTAL_RES,
+	SET_COB_CAL,
+	GET_COB_CAL_RES,
+	RDWR_EFUSE_USRDATA,
+	SET_NOTCH,
+    RDWR_PWROFSTFINE,
+    RDWR_EFUSE_PWROFSTFINE,
+    RDWR_EFUSE_SDIOCFG,
+    RDWR_EFUSE_USBVIDPID,
 };
 
 typedef struct {
@@ -1241,6 +1265,7 @@ typedef struct {
 	u8_l mode;
 	u8_l rate;
 	u16_l length;
+	u16_l tx_intv_us;
 } cmd_rf_settx_t;
 
 typedef struct {
@@ -1259,7 +1284,17 @@ typedef struct
 {
     u8_l dutid;
     u8_l chip_num;
+    u8_l dis_xtal;
 }cmd_rf_setcobcal_t;
+typedef struct
+ {
+     u16_l dut_rcv_golden_num;
+     u8_l golden_rcv_dut_num;
+     s8_l rssi_static;
+     s8_l snr_static;
+     s8_l dut_rssi_static;
+     u16_l reserved;
+ }cob_result_ptr_t;
 #endif
 
 #define CMD_MAXARGS 10
@@ -1403,9 +1438,12 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 	u8_l xtal_cap;
 	u8_l xtal_cap_fine;
 	u8_l vendor_info;
+	cob_result_ptr_t *cob_result_ptr;
 
 #endif
 
+	u8_l state;
+
 #ifdef CONFIG_GPIO_WAKEUP
 	u8_l setsusp_mode;
 	int ret = 0;
@@ -1442,8 +1480,13 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			settx_param.mode = command_strtoul(argv[3], NULL, 10);
 			settx_param.rate = command_strtoul(argv[4], NULL, 10);
 			settx_param.length = command_strtoul(argv[5], NULL, 10);
-			AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
-				settx_param.mode, settx_param.rate, settx_param.length);
+			if (argc > 6) {
+				settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
+			} else {
+				settx_param.tx_intv_us = 0;
+			}
+			AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
+				settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
 	#ifdef AICWF_SDIO_SUPPORT
 			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
 	#endif
@@ -1568,13 +1611,23 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			bytes_written = 4;
 		} else if (strcasecmp(argv[0], "SET_POWER") == 0) {
 			AICWFDBG(LOGINFO, "set_power\n");
-			ana_pwr = command_strtoul(argv[1], NULL, 16);
-			dig_pwr = command_strtoul(argv[2], NULL, 16);
-			pwr = (ana_pwr << 4 | dig_pwr);
-			if (ana_pwr > 0xf || dig_pwr > 0xf) {
-				AICWFDBG(LOGERROR, "invalid param\r\n");
-				bytes_written = -EINVAL;
-				break;
+			if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) {
+				ana_pwr = command_strtoul(argv[1], NULL, 16);
+				dig_pwr = command_strtoul(argv[2], NULL, 16);
+				pwr = (ana_pwr << 4 | dig_pwr);
+				if (ana_pwr > 0xf || dig_pwr > 0xf) {
+					AICWFDBG(LOGERROR, "invalid param\r\n");
+					bytes_written = -EINVAL;
+					break;
+				}
+			} else {
+				ana_pwr = command_strtoul(argv[1], NULL, 10);
+				pwr = ana_pwr;
+				if (ana_pwr > 0x1e) {
+					AICWFDBG(LOGERROR, "invalid param\r\n");
+					bytes_written = -EINVAL;
+					break;
+				}
 			}
 			AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
 	#ifdef AICWF_SDIO_SUPPORT
@@ -1765,7 +1818,8 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			u8_l func = 0;
 			#ifdef AICWF_SDIO_SUPPORT
 			if ((g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800DC)
-			&& (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800DW)) {
+			&& (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800DW)
+			&& (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
 				AICWFDBG(LOGINFO, "unsupported cmd\n");
 				bytes_written = -EINVAL;
 				break;
@@ -1820,10 +1874,16 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				bytes_written = -EINVAL;
 				break;
 			}
-			memcpy(command, &cfm.rftest_result[0], 3 * 12);
-			bytes_written = 3 * 12;
+			if(g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80){
+				memcpy(command, &cfm.rftest_result[0], 6 * 12);
+				bytes_written = 6 * 12;
+			} else {
+				memcpy(command, &cfm.rftest_result[0], 3 * 12);
+				bytes_written = 3 * 12;
+			}
 		} else if (strcasecmp(argv[0], "RDWR_PWROFST") == 0) {
 			u8_l func = 0;
+            int res_len = 0;
 			AICWFDBG(LOGINFO, "read/write txpwr offset\n");
 			if (argc > 1) {
 				func = (u8_l)command_strtoul(argv[1], NULL, 16);
@@ -1833,11 +1893,20 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
 	#endif
 			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if (argc > 3) {
+				if ((argc > 4) && (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80)) {
+                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+                    printk("set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+                    #ifdef AICWF_SDIO_SUPPORT
+                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+                    #endif
+                } else if ((argc > 3) && (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
 					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
 					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-					printk("set pwrofst:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+					printk("set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
 	#ifdef AICWF_SDIO_SUPPORT
 					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
 	#endif
@@ -1851,8 +1920,43 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				bytes_written = -EINVAL;
 				break;
 			}
-			memcpy(command, &cfm.rftest_result[0], 7);
-			bytes_written = 7;
+            if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
+                (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
+                res_len = 3;
+            } else if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+                res_len = 3 * 3 + 3 * 6;
+            } else {
+                res_len = 3 + 4;
+            }
+			memcpy(command, &cfm.rftest_result[0], res_len);
+			bytes_written = res_len;
+        } else if (strcasecmp(argv[0], "RDWR_PWROFSTFINE") == 0) {
+            u8_l func = 0;
+            AICWFDBG(LOGINFO, "read/write txpwr offset fine\n");
+            if (argc > 1) {
+                func = (u8_l)command_strtoul(argv[1], NULL, 16);
+            }
+            if (func == 0) { // read cur
+                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
+            } else if (func <= 2) { // write 2.4g/5g pwr ofst
+                if (argc > 3) {
+                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+                    AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
+                } else {
+                    AICWFDBG(LOGERROR, "wrong args\n");
+                    bytes_written = -EINVAL;
+                    break;
+                }
+            } else {
+                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+                bytes_written = -EINVAL;
+                break;
+            }
+            memcpy(command, &cfm.rftest_result[0], 7);
+            bytes_written = 7;
 		} else if (strcasecmp(argv[0], "RDWR_DRVIBIT") == 0) {
 			u8_l func = 0;
 			AICWFDBG(LOGINFO, "read/write pa drv_ibit\n");
@@ -1885,6 +1989,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			bytes_written = 16;
 		} else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFST") == 0) {
 			u8_l func = 0;
+            int res_len = 0;
 			AICWFDBG(LOGINFO, "read/write txpwr offset into efuse\n");
 			if (argc > 1) {
 				func = (u8_l)command_strtoul(argv[1], NULL, 16);
@@ -1894,11 +1999,20 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
 	#endif
 			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if (argc > 3) {
+				if ((argc > 4) && (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80)) {
+                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+                    printk("set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+                    #ifdef AICWF_SDIO_SUPPORT
+                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+                    #endif
+                } else if ((argc > 3) && (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
 					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
 					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
 					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-					printk("set efuse pwrofst:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+					printk("set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
 	#ifdef AICWF_SDIO_SUPPORT
 					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
 	#endif
@@ -1914,12 +2028,14 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			}
             if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
                 (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                memcpy(command, &cfm.rftest_result[0], 6);
-                bytes_written = 6;
+                res_len = 3 * 2;
+            } else if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+                res_len = 3 * 3 + 3 * 6;
             } else { // 7 = 3(2.4g) + 4(5g)
-                memcpy(command, &cfm.rftest_result[0], 7);
-                bytes_written = 7;
+                res_len = 3 + 4;
             }
+            memcpy(command, &cfm.rftest_result[0], res_len);
+            bytes_written = res_len;
 		} else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
 			u8_l func = 0;
 			AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
@@ -1950,6 +2066,39 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			}
 			memcpy(command, &cfm.rftest_result[0], 4);
 			bytes_written = 4;
+        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFSTFINE") == 0) {
+            u8_l func = 0;
+            AICWFDBG(LOGINFO, "read/write txpwr offset fine into efuse\n");
+            if (argc > 1) {
+                func = (u8_l)command_strtoul(argv[1], NULL, 16);
+            }
+            if (func == 0) { // read cur
+                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
+            } else if (func <= 2) { // write 2.4g/5g pwr ofst
+                if (argc > 3) {
+                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+                    AICWFDBG(LOGINFO, "set efuse pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
+                } else {
+                    AICWFDBG(LOGERROR, "wrong args\n");
+                    bytes_written = -EINVAL;
+                    break;
+                }
+            } else {
+                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+                bytes_written = -EINVAL;
+                break;
+            }
+            if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
+                (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
+                memcpy(command, &cfm.rftest_result[0], 6);
+                bytes_written = 6;
+            } else { // 7 = 3(2.4g) + 4(5g)
+                memcpy(command, &cfm.rftest_result[0], 7);
+                bytes_written = 7;
+            }
 		} else if (strcasecmp(argv[0], "SET_PAPR") == 0) {
 			AICWFDBG(LOGINFO, "set papr\n");
 			if (argc > 1) {
@@ -1957,6 +2106,18 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				AICWFDBG(LOGINFO, "papr %d\r\n", func);
 	#ifdef AICWF_SDIO_SUPPORT
 				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_PAPR, sizeof(func), &func, NULL);
+	#endif
+			} else {
+				AICWFDBG(LOGERROR, "wrong args\n");
+				bytes_written = -EINVAL;
+				break;
+			}
+		} else if (strcasecmp(argv[0], "SET_NOTCH") == 0) {
+			if (argc > 1) {
+				u8_l func = (u8_l) command_strtoul(argv[1], NULL, 10);
+				AICWFDBG(LOGINFO, "set notch %d\r\n", func);
+	#ifdef AICWF_SDIO_SUPPORT
+				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_NOTCH, sizeof(func), &func, NULL);
 	#endif
 			} else {
 				AICWFDBG(LOGERROR, "wrong args\n");
@@ -1972,6 +2133,7 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 				   }
 				   setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
 				   setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
+				   setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
 				   rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
 		} else if (strcasecmp(argv[0], "GET_COB_CAL_RES")==0) {
 			AICWFDBG(LOGINFO, "get cob cal res\n");
@@ -1979,6 +2141,58 @@ int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
 			memcpy(command, &cfm.rftest_result[0], 4);
 			bytes_written = 4;
 			AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
+		} else if (strcasecmp(argv[0], "DO_COB_TEST") == 0) {
+             AICWFDBG(LOGINFO, "do_cob_test\n");
+             setcob_cal.dutid = 1;
+             setcob_cal.chip_num = 1;
+             setcob_cal.dis_xtal = 0;
+             if (argc > 1 ) {
+                 setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
+             }
+             rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+             msleep(2000);
+             rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+             state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+             if (!state){
+                 AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+                 cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+                 cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+                 AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+                 cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+                 cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+                 memcpy(command, &cfm.rftest_result, 16);
+                 bytes_written = 16;
+             } else {
+                 AICWFDBG(LOGERROR, "cob not idle\n");
+                 bytes_written = -EINVAL;
+                 break;
+             }
+        } else if (strcasecmp(argv[0], "RDWR_EFUSE_SDIOCFG") == 0) {
+            u8_l func = 0;
+            AICWFDBG(LOGINFO, "read/write sdiocfg_bit into efuse\n");
+            if (argc > 1) {
+                func = (u8_l)command_strtoul(argv[1], NULL, 16);
+            }
+            if (func == 0) { // read cur
+                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
+            } else if (func == 1) { // write sdiocfg
+                if (argc > 2) {
+                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+                u8_l buf[2] = {func, ibit};
+                AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
+                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
+                } else {
+                    AICWFDBG(LOGERROR, "wrong args\n");
+                    bytes_written = -EINVAL;
+                    break;
+                }
+            } else {
+                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+                bytes_written = -EINVAL;
+                break;
+            }
+            memcpy(command, &cfm.rftest_result[0], 4);
+            bytes_written = 4;
 		} else if (strcasecmp(argv[0], "SETSUSPENDMODE") == 0 && testmode == 0) {
 	#ifdef AICWF_SDIO_SUPPORT
 			#ifdef CONFIG_GPIO_WAKEUP
@@ -2412,7 +2626,7 @@ static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, int cmd)
 		break;
 	case (SIOCDEVPRIVATE+1):
 		AICWFDBG(LOGINFO, "IOCTL PRIVATE\n");
-		android_priv_cmd(net, req, cmd);
+		ret = android_priv_cmd(net, req, cmd);
 		break;
 	case (SIOCDEVPRIVATE+2):
 		AICWFDBG(LOGINFO, "IOCTL PRIVATE+2\n");
@@ -2487,7 +2701,9 @@ static const struct net_device_ops rwnx_netdev_ops = {
 	.ndo_do_ioctl           = rwnx_do_ioctl,
 	.ndo_start_xmit         = rwnx_start_xmit,
 	.ndo_get_stats          = rwnx_get_stats,
+#ifndef CONFIG_ONE_TXQ
 	.ndo_select_queue       = rwnx_select_queue,
+#endif
 #ifdef CONFIG_SUPPORT_REALTIME_CHANGE_MAC
 	.ndo_set_mac_address    = rwnx_set_mac_address
 #endif
@@ -2542,7 +2758,6 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
     int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
 
     if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) ||
-		(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) ||
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 		    nx_nb_ndev_txq = NX_NB_NDEV_TXQ_FOR_OLD_IC;
@@ -2579,8 +2794,14 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
 	}
 	#endif
 
-	ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
-							rwnx_netdev_setup, nx_nb_ndev_txq, 1);
+#ifndef CONFIG_ONE_TXQ
+    ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
+                                rwnx_netdev_setup, nx_nb_ndev_txq, 1);
+#else
+    ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
+                                    rwnx_netdev_setup, 1, 1);
+#endif
+
 	if (!ndev)
 		return NULL;
 
@@ -2679,8 +2900,12 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
 	} else
 		vif->use_4addr = false;
 
-	if (register_netdevice(ndev))
-		goto err;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        if (cfg80211_register_netdevice(ndev))
+#else
+        if (register_netdevice(ndev))
+#endif
+            goto err;
 
 	spin_lock_bh(&rwnx_hw->cb_lock);
 	list_add_tail(&vif->list, &rwnx_hw->vifs);
@@ -2748,6 +2973,7 @@ void aicwf_p2p_alive_timeout(struct timer_list *t)
 
 		rwnx_vif->up = false;
 		rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+        AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
 		rwnx_hw->vif_started--;
 		spin_unlock_bh(&rwnx_hw->cb_lock);
 	}
@@ -2946,8 +3172,13 @@ static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wde
 	netdev_info(dev, "Remove Interface");
 
 	if (dev->reg_state == NETREG_REGISTERED) {
-		/* Will call rwnx_close if interface is UP */
-		unregister_netdevice(dev);
+        /* Will call rwnx_close if interface is UP */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        cfg80211_unregister_netdevice(dev);
+#else
+        unregister_netdevice(dev);
+#endif
+
 	}
 
 	spin_lock_bh(&rwnx_hw->cb_lock);
@@ -3135,6 +3366,7 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 			spin_lock_bh(&rwnx_hw->cb_lock);
 			rwnx_vif->up = false;
 			rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+            AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
 			rwnx_hw->vif_started--;
 			spin_unlock_bh(&rwnx_hw->cb_lock);
 		}
@@ -3171,11 +3403,14 @@ static int rwnx_cfg80211_scan(struct wiphy *wiphy,
 	}
 
 	if (scanning) {
-		AICWFDBG(LOGERROR, "is scanning, abort\n");
+		AICWFDBG(LOGERROR, "%s is scanning, abort\n", __func__);
+        #if 0
 		error =  rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
 		if (error)
 			return error;
 		msleep(150);
+        #endif
+        return -EBUSY;
 	}
 
 	rwnx_hw->scan_request = request;
@@ -3192,6 +3427,9 @@ bool key_flag = false;
  *	when adding a group key.
  */
 static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                                                 int link_id,
+#endif
 								 u8 key_index, bool pairwise, const u8 *mac_addr,
 								 struct key_params *params)
 {
@@ -3285,6 +3523,9 @@ static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  *
  */
 static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                                                 int link_id,
+#endif
 								 u8 key_index, bool pairwise, const u8 *mac_addr,
 								 void *cookie,
 								 void (*callback)(void *cookie, struct key_params*))
@@ -3300,6 +3541,9 @@ static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
  *	and @key_index, return -ENOENT if the key doesn't exist.
  */
 static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                                                 int link_id,
+#endif
 								 u8 key_index, bool pairwise, const u8 *mac_addr)
 {
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
@@ -3336,6 +3580,9 @@ static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
 										 struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                                                                 int link_id,
+#endif
 										 u8 key_index, bool unicast, bool multicast)
 {
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
@@ -3348,6 +3595,9 @@ static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
  */
 static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
 											  struct net_device *netdev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                                                                          int link_id,
+#endif
 											  u8 key_index)
 {
 	return 0;
@@ -3423,7 +3673,11 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		key_params.key_len = sme->key_len;
 		key_params.seq_len = 0;
 		key_params.cipher = sme->crypto.cipher_group;
-		rwnx_cfg80211_add_key(wiphy, dev, sme->key_idx, false, NULL, &key_params);
+		rwnx_cfg80211_add_key(wiphy, dev, 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41))
+                                0,
+#endif
+				sme->key_idx, false, NULL, &key_params);
 	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
 	else if ((sme->auth_type == NL80211_AUTHTYPE_SAE) &&
@@ -3509,6 +3763,109 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 
 }
 
+#ifdef CONFIG_SCHED_SCAN
+
+static int rwnx_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+					   struct net_device *ndev
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+					   ,u64 reqid)
+#else
+                        )
+#endif
+{
+
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	//struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
+
+    if(rwnx_hw->scan_request){
+        AICWFDBG(LOGINFO, "%s rwnx_send_scanu_cancel_req\r\n", __func__);
+        return rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
+    }else{
+        return 0;
+    }
+}
+
+
+static int rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy,
+                             struct net_device *dev,
+                             struct cfg80211_sched_scan_request *request)
+
+{
+    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+    struct cfg80211_scan_request *scan_request = NULL;
+
+    int ret = 0;
+    int index = 0;
+
+    AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
+
+    if(rwnx_hw->is_sched_scan || scanning){
+        AICWFDBG(LOGERROR, "%s is_sched_scanning and scanning, busy", __func__);
+        return -EBUSY;
+    }
+
+    scan_request = (struct cfg80211_scan_request *)kmalloc(sizeof(struct cfg80211_scan_request), GFP_KERNEL);
+
+    scan_request->ssids = request->ssids;
+    scan_request->n_channels = request->n_channels;
+    scan_request->n_ssids = request->n_match_sets;
+    scan_request->no_cck = false;
+	scan_request->ie = request->ie;
+	scan_request->ie_len = request->ie_len;
+    scan_request->flags = request->flags;
+
+    scan_request->wiphy = wiphy;
+    scan_request->scan_start = request->scan_start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+    memcpy(scan_request->mac_addr, request->mac_addr, ETH_ALEN);
+    memcpy(scan_request->mac_addr_mask, request->mac_addr_mask, ETH_ALEN);
+#endif
+    rwnx_hw->sched_scan_req = request;
+    scan_request->wdev = &rwnx_vif->wdev;
+    AICWFDBG(LOGDEBUG, "%s scan_request->n_channels:%d \r\n", __func__, scan_request->n_channels);
+    AICWFDBG(LOGDEBUG, "%s scan_request->n_ssids:%d \r\n", __func__, scan_request->n_ssids);
+
+    for(index = 0; index < scan_request->n_ssids; index++){
+        memset(scan_request->ssids[index].ssid, 0, IEEE80211_MAX_SSID_LEN);
+
+        memcpy(scan_request->ssids[index].ssid,
+            request->match_sets[index].ssid.ssid,
+            IEEE80211_MAX_SSID_LEN);
+
+        scan_request->ssids[index].ssid_len = request->match_sets[index].ssid.ssid_len;
+
+        AICWFDBG(LOGDEBUG, "%s request ssid:%s len:%d \r\n", __func__,
+            scan_request->ssids[index].ssid, scan_request->ssids[index].ssid_len);
+    }
+
+	for(index = 0;index < scan_request->n_channels; index++){
+		scan_request->channels[index] = request->channels[index];
+
+        AICWFDBG(LOGDEBUG, "%s scan_request->channels[%d]:%d \r\n", __func__, index,
+            scan_request->channels[index]->center_freq);
+
+		if(scan_request->channels[index] == NULL){
+			AICWFDBG(LOGERROR, "%s ERROR!!! channels is NULL", __func__);
+			continue;
+		}
+	}
+
+    rwnx_hw->is_sched_scan = true;
+
+    if(scanning){
+        AICWFDBG(LOGERROR, "%s scanning, about it", __func__);
+        kfree(scan_request);
+        return -EBUSY;
+    }else{
+        ret = rwnx_cfg80211_scan(wiphy, scan_request);
+    }
+
+	return ret;
+}
+#endif //CONFIG_SCHED_SCAN
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
 /**
  * @external_auth: indicates result of offloaded authentication processing from
@@ -3577,8 +3934,13 @@ static int rwnx_cfg80211_add_station(struct wiphy *wiphy,
 		sta->vif_idx = rwnx_vif->vif_index;
 		sta->vlan_idx = sta->vif_idx;
 		sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
-		sta->ht = params->ht_capa ? 1 : 0;
-		sta->vht = params->vht_capa ? 1 : 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41)
+                sta->ht = params->link_sta_params.ht_capa ? 1 : 0;
+                sta->vht = params->link_sta_params.vht_capa ? 1 : 0;
+#else
+                sta->ht = params->ht_capa ? 1 : 0;
+                sta->vht = params->vht_capa ? 1 : 0;
+#endif
 		sta->acm = 0;
 		sta->key.hw_idx = 0;
 
@@ -3978,8 +4340,13 @@ static int rwnx_cfg80211_change_station(struct wiphy *wiphy,
 				sta->vif_idx = rwnx_vif->vif_index;
 				sta->vlan_idx = sta->vif_idx;
 				sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
-				sta->ht = params->ht_capa ? 1 : 0;
-				sta->vht = params->vht_capa ? 1 : 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41)
+                                sta->ht = params->link_sta_params.ht_capa ? 1 : 0;
+                                sta->vht = params->link_sta_params.vht_capa ? 1 : 0;
+#else
+                                sta->ht = params->ht_capa ? 1 : 0;
+                                sta->vht = params->vht_capa ? 1 : 0;
+#endif
 				sta->acm = 0;
 				for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
 					int uapsd_bit = rwnx_hwq2uapsd[rwnx_tid2hwq[tid]];
@@ -4220,7 +4587,11 @@ static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *d
 /**
  * * @stop_ap: Stop being an AP, including stopping beaconing.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0))
+static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev, unsigned int link_id)
+#else
 static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
+#endif
 {
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
@@ -4665,7 +5036,12 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
 		info->noise = rwnx_survey->noise_dbm;
 
 		// Set the survey report as not used
-		rwnx_survey->filled = 0;
+        if(info->noise == 0){
+		    rwnx_survey->filled = 0;
+        }else{
+            rwnx_survey->filled |= SURVEY_INFO_NOISE_DBM;
+        }
+
 	}
 
 	return 0;
@@ -4677,8 +5053,11 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
  *	current monitoring channel.
  */
 static int rwnx_cfg80211_get_channel(struct wiphy *wiphy,
-									 struct wireless_dev *wdev,
-									 struct cfg80211_chan_def *chandef)
+                                                                         struct wireless_dev *wdev,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+                                                                         unsigned int link_id,
+#endif
+                                                                         struct cfg80211_chan_def *chandef)
 {
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
@@ -4969,11 +5348,22 @@ int rwnx_cfg80211_channel_switch (struct wiphy *wiphy,
 		goto end;
 	} else {
 		INIT_WORK(&csa->work, rwnx_csa_finish);
-		rwnx_cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count
-			#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
-				, params->block_tx
-			#endif
-				);
+                rwnx_cfg80211_ch_switch_started_notify(dev
+                                        , &csa->chandef
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+                                        , 0
+#endif
+                                        , params->count
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+                                        , false
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+                                        , params->block_tx
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 94)
+                                        , 0
+#endif
+                                        );
+	
 	}
 
 end:
@@ -5277,7 +5667,11 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+        if(rate_info->mcsIndexTx > 9){
+            sinfo->txrate.mcs = 9;
+        }else{
+		    sinfo->txrate.mcs = rate_info->mcsIndexTx;
+        }
 		break;
 #endif
 	default:
@@ -5378,7 +5772,11 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->rxrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-		sinfo->rxrate.mcs = rx_vect1->he.mcs;
+        if(rx_vect1->he.mcs > 9){
+            sinfo->rxrate.mcs = 9;
+        }else{
+            sinfo->rxrate.mcs = rx_vect1->he.mcs;
+        }
 		break;
 #endif
 	default:
@@ -5967,6 +6365,10 @@ static struct cfg80211_ops rwnx_cfg80211_ops = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
 	.external_auth = rwnx_cfg80211_external_auth,
 #endif
+#ifdef CONFIG_SCHED_SCAN
+    .sched_scan_start = rwnx_cfg80211_sched_scan_start,
+    .sched_scan_stop = rwnx_cfg80211_sched_scan_stop,
+#endif
 };
 
 
@@ -6077,6 +6479,33 @@ int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw){
 
 	chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
 
+    if (rwnx_send_dbg_mem_read_req(rwnx_hw, 0x00000020, &rd_mem_addr_cfm)) {
+		AICWFDBG(LOGERROR, "[0x00000020] rd fail\n");
+        return -1;
+    }
+    chip_sub_id = (u8)(rd_mem_addr_cfm.memdata);
+
+	AICWFDBG(LOGINFO, "FDRV chip_id=%x, chip_sub_id=%x!!\n", chip_id, chip_sub_id);
+
+#ifdef CONFIG_OOB
+    if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+        u32 memdata_temp = 0x00000006;
+        int ret;
+        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, 0x40504084, 4, &memdata_temp);
+        if (ret) {
+            AICWFDBG(LOGERROR, "[0x40504084] write fail: %d\n", ret);
+            return -1;
+        }
+
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40504084, &rd_mem_addr_cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "[0x40504084] rd fail\n");
+            return -1;
+        }
+        AICWFDBG(LOGINFO, "rd [0x40504084] = %x\n", rd_mem_addr_cfm.memdata);
+    }
+#endif
+
 	if (rwnx_platform_on(rwnx_hw, NULL))
 			return -1;
 #if defined(CONFIG_START_FROM_BOOTROM)
@@ -6100,8 +6529,10 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 			return -1;
 		}
 
-		if ((ret = rwnx_send_rf_calib_req(rwnx_hw, &cfm)))
-			return -1;
+		if (testmode == 0) {
+			if ((ret = rwnx_send_rf_calib_req(rwnx_hw, &cfm)))
+				return -1;
+		}
 
 	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 			rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
@@ -6118,7 +6549,53 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 }
 
 
+#ifdef CONFIG_PLATFORM_ALLWINNER
+#ifdef CONFIG_USE_CUSTOMER_MAC
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+extern int get_custom_mac_address(int fmt, char *name, char *addr);
+#else
+extern int get_wifi_custom_mac_address(char *addr_str);
+#endif
+#endif//CONFIG_USE_CUSTOMER_MAC
+#endif//CONFIG_PLATFORM_ALLWINNER
+
+#ifdef CONFIG_PLATFORM_ROCKCHIP
+#include <linux/rfkill-wlan.h>
+#endif
+
+#ifdef CONFIG_USE_CUSTOMER_MAC
+int rwnx_get_custom_mac_addr(u8_l *mac_addr_efuse){
+    int ret = 0;
+
+#ifdef CONFIG_PLATFORM_ALLWINNER
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+        ret = get_custom_mac_address(1, "wifi", mac_addr_efuse);
+#else
+        ret = get_wifi_custom_mac_address(addr_str);
+        if (ret >= 0) {
+            sscanf(addr_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+                    &mac_addr_efuse[0], &mac_addr_efuse[1], &mac_addr_efuse[2],
+                    &mac_addr_efuse[3], &mac_addr_efuse[4], &mac_addr_efuse[5]);
+        }
+#endif
+
+#endif//CONFIG_PLATFORM_ALLWINNER
 
+#ifdef CONFIG_PLATFORM_ROCKCHIP
+        ret = rockchip_wifi_mac_addr(mac_addr_efuse);
+#endif//CONFIG_PLATFORM_ROCKCHIP
+
+    if(ret == 0){
+        AICWFDBG(LOGINFO, "%s %02x:%02x:%02x:%02x:%02x:%02x", __func__,
+            mac_addr_efuse[0], mac_addr_efuse[1], mac_addr_efuse[2],
+            mac_addr_efuse[3], mac_addr_efuse[4], mac_addr_efuse[5]);
+    }
+
+    return ret;
+}
+#endif
+
+extern void *aicwf_prealloc_txq_alloc(size_t size);
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 {
 	struct rwnx_hw *rwnx_hw;
@@ -6145,6 +6622,7 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	get_random_bytes(&dflt_mac[4], 2);
 
 	/* create a new wiphy for use with cfg80211 */
+    AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__, (int)sizeof(struct rwnx_hw));
 	wiphy = wiphy_new(&rwnx_cfg80211_ops, sizeof(struct rwnx_hw));
 
 	if (!wiphy) {
@@ -6169,6 +6647,11 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	rwnx_hw->mod_params = &rwnx_mod_params;
 	rwnx_hw->tcp_pacing_shift = 7;
 
+#ifdef CONFIG_SCHED_SCAN
+    rwnx_hw->is_sched_scan = false;
+#endif//CONFIG_SCHED_SCAN
+
+    aicwf_wakeup_lock_init(rwnx_hw);
 	rwnx_init_aic(rwnx_hw);
 	/* set device pointer for wiphy */
 	set_wiphy_dev(wiphy, rwnx_hw->dev);
@@ -6202,6 +6685,10 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 
 	rwnx_hwq_init(rwnx_hw);
 
+#ifdef CONFIG_PREALLOC_TXQ
+        rwnx_hw->txq = (struct rwnx_txq*)aicwf_prealloc_txq_alloc(sizeof(struct rwnx_txq)*NX_NB_TXQ);
+#endif
+
 	for (i = 0; i < NX_NB_TXQ; i++) {
 		rwnx_hw->txq[i].idx = TXQ_INACTIVE;
 	}
@@ -6237,15 +6724,23 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 		goto err_lmac_reqs;
 	}
 
+    //ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, feature.hwinfo < 0, feature.hwinfo, 0, &set_start_cfm);
 #ifdef USE_5G
-	ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), 0, &set_start_cfm);
-	if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
-		set_start_cfm.is_5g_support = false;
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801) {
+	    ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), 0, &set_start_cfm);
 	}
 #else
-	ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, feature.hwinfo < 0, feature.hwinfo, 0, &set_start_cfm);
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801) {
+	    ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, 0, 0, &set_start_cfm);
+	}
 #endif
+    else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+			rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+		ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, 0, 0, &set_start_cfm);
+        set_start_cfm.is_5g_support = false;
+	} else {
+		ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), 0, &set_start_cfm);
+	}
 
 	if (ret)
 		goto err_lmac_reqs;
@@ -6333,6 +6828,15 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	wiphy->extended_capabilities_mask = rwnx_hw->ext_capa;
 	wiphy->extended_capabilities_len = ARRAY_SIZE(rwnx_hw->ext_capa);
 
+#ifdef CONFIG_SCHED_SCAN
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+    wiphy->max_sched_scan_reqs = 1;
+#endif
+    wiphy->max_sched_scan_ssids = SCAN_SSID_MAX;//16;
+    wiphy->max_match_sets = SCAN_SSID_MAX;//16;
+    wiphy->max_sched_scan_ie_len = 2048;
+#endif//CONFIG_SCHED_SCAN
+
 	tasklet_init(&rwnx_hw->task, rwnx_task, (unsigned long)rwnx_hw);
 
 	//init ic rf
@@ -6341,28 +6845,24 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	}
 
 
-#if IS_ENABLED(CONFIG_SUNXI_ADDR_MGT)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
-	ret = get_custom_mac_address(1, "wifi", mac_addr_efuse);
+#ifdef CONFIG_USE_CUSTOMER_MAC
+    ret = rwnx_get_custom_mac_addr(mac_addr_efuse);
+	if (ret){
+        AICWFDBG(LOGERROR, "%s read mac fail use default mac\r\n", __func__);
+        memcpy(init_conf.mac_addr, dflt_mac, ETH_ALEN);
+    }
 #else
-	ret = get_wifi_custom_mac_address(addr_str);
-	if (ret >= 0) {
-		sscanf(addr_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
-				&mac_addr_efuse[0], &mac_addr_efuse[1], &mac_addr_efuse[2],
-				&mac_addr_efuse[3], &mac_addr_efuse[4], &mac_addr_efuse[5]);
-	}
-#endif
-	if (ret < 0)
+	ret = rwnx_send_get_macaddr_req(rwnx_hw, (struct mm_get_mac_addr_cfm *)mac_addr_efuse);
+	if (ret)
+		goto err_lmac_reqs;
 #endif
-	{
-		ret = rwnx_send_get_macaddr_req(rwnx_hw, (struct mm_get_mac_addr_cfm *)mac_addr_efuse);
-		if (ret)
-			goto err_lmac_reqs;
-	}
 
 	if (mac_addr_efuse[0] | mac_addr_efuse[1] | mac_addr_efuse[2] | mac_addr_efuse[3]) {
 		memcpy(init_conf.mac_addr, mac_addr_efuse, ETH_ALEN);
-	}
+	}else{
+        memcpy(init_conf.mac_addr, dflt_mac, ETH_ALEN);
+    }
+
 
 	AICWFDBG(LOGINFO, "get macaddr: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
 			mac_addr_efuse[0], mac_addr_efuse[1], mac_addr_efuse[2],
@@ -6491,6 +6991,7 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 //err_config:
 	kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
 err_cache:
+    aicwf_wakeup_lock_deinit(rwnx_hw);
 	wiphy_free(wiphy);
 err_out:
 	return ret;
@@ -6536,6 +7037,7 @@ void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
 	rwnx_radar_detection_deinit(&rwnx_hw->radar);
 	rwnx_platform_off(rwnx_hw, NULL);
 	kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+    aicwf_wakeup_lock_deinit(rwnx_hw);
 	wiphy_free(rwnx_hw->wiphy);
 }
 
@@ -6598,6 +7100,7 @@ static int __init rwnx_mod_init(void)
 #ifdef AICWF_USB_SUPPORT
 		aicwf_usb_exit();
 #endif /*AICWF_USB_SUPPORT */
+        aicbsp_set_subsys(AIC_WIFI, AIC_PWR_OFF);
 		return -ENODEV;
 	}
 
@@ -6633,6 +7136,11 @@ static void __exit rwnx_mod_exit(void)
 
 }
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
 module_init(rwnx_mod_init);
 module_exit(rwnx_mod_exit);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
old mode 100755
new mode 100644
index a496a77cc..684ab081f
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
@@ -34,4 +34,7 @@ extern u8 chip_sub_id;
 extern u8 chip_mcu_id;
 extern u8 chip_id;
 
+#define CHIP_ID_H_MASK  0xC0
+#define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
+
 #endif /* _RWNX_MAIN_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mesh.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
old mode 100755
new mode 100644
index 8062e0284..30f369f0c
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -770,7 +770,6 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
 			mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
-			printk("lemon map=%x\n", rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map);
 		}
 		for (; i < 8; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -1683,6 +1682,12 @@ int rwnx_handle_dynparams(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
         rwnx_hw->mod_params->use_80 = true;    
     }
+    
+    if (rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80 &&
+        rwnx_hw->mod_params->he_mcs_map == IEEE80211_HE_MCS_SUPPORT_0_11) {
+        AICWFDBG(LOGINFO,"%s unsupport mcs11 change to mcs9", __func__);
+        rwnx_hw->mod_params->he_mcs_map = IEEE80211_HE_MCS_SUPPORT_0_9;
+    }
 
 	/* Set wiphy parameters */
 	rwnx_set_wiphy_params(rwnx_hw, wiphy);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
old mode 100755
new mode 100644
index 5b264e23a..eb07e7cce
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -572,7 +572,11 @@ static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
 {
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-	if (rwnx_hw->scan_request) {
+	if (rwnx_hw->scan_request
+#ifdef CONFIG_SCHED_SCAN
+        && !rwnx_hw->is_sched_scan
+#endif//CONFIG_SCHED_SCAN
+        ) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 		struct cfg80211_scan_info info = {
 			.aborted = false,
@@ -584,6 +588,21 @@ static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
 #endif
 	}
 
+#ifdef CONFIG_SCHED_SCAN
+    if(rwnx_hw->is_sched_scan){
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+        AICWFDBG(LOGINFO, "%s cfg80211_sched_scan_results \r\n", __func__);
+        cfg80211_sched_scan_results(rwnx_hw->scan_request->wiphy, 
+                rwnx_hw->sched_scan_req->reqid);
+#else
+        cfg80211_sched_scan_results(rwnx_hw->sched_scan_req->wiphy);
+#endif  
+        kfree(rwnx_hw->scan_request);
+        rwnx_hw->is_sched_scan = false;
+    }
+#endif//CONFIG_SCHED_SCAN
+
 	rwnx_hw->scan_request = NULL;
 	scanning = 0;
 
@@ -796,45 +815,62 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 	} else if (ind->status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {
 		if (rwnx_vif->wep_enabled) {
 			rwnx_vif->wep_auth_err = true;
-			printk("con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
+			AICWFDBG(LOGINFO, "con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
 		}
 		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}else{
 		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}
 
-	if (!ind->roamed)
+    AICWFDBG(LOGINFO, "%s ind->roamed:%d ind->status_code:%d rwnx_vif->drv_conn_state:%d\r\n", 
+        __func__, 
+        ind->roamed, 
+        ind->status_code,
+        (int)atomic_read(&rwnx_vif->drv_conn_state));
+
+
+	if (!ind->roamed){//not roaming
 		cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
 								ind->assoc_req_ie_len, rsp_ie,
 								ind->assoc_rsp_ie_len, ind->status_code,
 								GFP_ATOMIC);
-	else {
+    }else {//roaming
+        if(ind->status_code != 0){
+            AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
+			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
+        }else{        
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
-		struct cfg80211_roam_info info;
-		memset(&info, 0, sizeof(info));
-		if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
-			info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
-		info.bssid = (const u8 *)ind->bssid.array;
-		info.req_ie = req_ie;
-		info.req_ie_len = ind->assoc_req_ie_len;
-		info.resp_ie = rsp_ie;
-		info.resp_ie_len = ind->assoc_rsp_ie_len;
-		cfg80211_roamed(dev, &info, GFP_ATOMIC);
+    		struct cfg80211_roam_info info;
+    		memset(&info, 0, sizeof(info));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+            if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+                    info.links[0].channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+            info.links[0].bssid = (const u8 *)ind->bssid.array;
+#else
+            if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+                    info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+            info.bssid = (const u8 *)ind->bssid.array;
+#endif
+    		info.req_ie = req_ie;
+    		info.req_ie_len = ind->assoc_req_ie_len;
+    		info.resp_ie = rsp_ie;
+    		info.resp_ie_len = ind->assoc_rsp_ie_len;
+    		cfg80211_roamed(dev, &info, GFP_ATOMIC);
 #else
-		chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
-		cfg80211_roamed(dev
+    		chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
+    		cfg80211_roamed(dev
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
-			, chan
+    			, chan
 #endif
-			, (const u8 *)ind->bssid.array
-			, req_ie
-			, ind->assoc_req_ie_len
-			, rsp_ie
-			, ind->assoc_rsp_ie_len
-			, GFP_ATOMIC);
+    			, (const u8 *)ind->bssid.array
+    			, req_ie
+    			, ind->assoc_req_ie_len
+    			, rsp_ie
+    			, ind->assoc_rsp_ie_len
+    			, GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-	}
-
+    	}
+        }
 	netif_tx_start_all_queues(dev);
 	netif_carrier_on(dev);
 
@@ -874,7 +910,7 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 	if (rwnx_vif->up) {
 		if (!ind->ft_over_ds && !ind->reassoc) {
 			cfg80211_disconnected(dev, ind->reason_code, NULL, 0,
-								  (ind->reason_code <= 1), GFP_ATOMIC);
+								  (ind->reason_code < 1), GFP_ATOMIC);
 		}
 		netif_tx_stop_all_queues(dev);
 		netif_carrier_off(dev);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
old mode 100755
new mode 100644
index 2a45e13c9..71f258841
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -21,6 +21,7 @@
 #include "aicwf_txrxif.h"
 #include "rwnx_strs.h"
 #include "rwnx_main.h"
+#include "rwnx_wakelock.h"
 
 const struct mac_addr mac_addr_bcst = {{0xFFFF, 0xFFFF, 0xFFFF}};
 
@@ -293,8 +294,8 @@ static void rwnx_msg_free(struct rwnx_hw *rwnx_hw, const void *msg_params)
 	kfree(msg);
 }
 
-void rwnx_pm_relax(struct aic_sdio_dev *sdiodev);
-void rwnx_pm_stay_awake(struct aic_sdio_dev *sdiodev);
+//void rwnx_pm_relax(struct aic_sdio_dev *sdiodev);
+//void rwnx_pm_stay_awake(struct aic_sdio_dev *sdiodev);
 
 static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
 						 int reqcfm, lmac_msg_id_t reqid, void *cfm)
@@ -318,11 +319,11 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
 	}
 #endif
 #ifdef AICWF_SDIO_SUPPORT
-	rwnx_pm_stay_awake(rwnx_hw->sdiodev);
+	rwnx_wakeup_lock(rwnx_hw->ws_tx);
 	if (rwnx_hw->sdiodev->bus_if->state == BUS_DOWN_ST) {
 		rwnx_msg_free(rwnx_hw, msg_params);
 		sdio_err("bus is down\n");
-		rwnx_pm_relax(rwnx_hw->sdiodev);
+		rwnx_wakeup_unlock(rwnx_hw->ws_tx);
 		return 0;
 	}
 #endif
@@ -399,7 +400,7 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
 	if (!reqcfm || ret)
 		rwnx_cmd_free(cmd);//kfree(cmd);
 
-	rwnx_pm_relax(rwnx_hw->sdiodev);
+	rwnx_wakeup_unlock(rwnx_hw->ws_tx);
 	return 0;
 }
 
@@ -416,7 +417,7 @@ static int rwnx_send_msg1(struct rwnx_hw *rwnx_hw, const void *msg_params,
     printk("%s (%d)%s reqcfm:%d in_irq:%d in_softirq:%d in_atomic:%d\r\n",
     __func__, reqid, RWNX_ID2STR(reqid), reqcfm, (int)in_irq(), (int)in_softirq(), (int)in_atomic());
 
-	rwnx_pm_stay_awake(rwnx_hw->sdiodev);
+	rwnx_wakeup_lock(rwnx_hw->ws_tx);
 	msg = container_of((void *)msg_params, struct lmac_msg, param);
 
 	//nonblock = is_non_blocking_msg(msg->id);
@@ -446,7 +447,7 @@ static int rwnx_send_msg1(struct rwnx_hw *rwnx_hw, const void *msg_params,
 	if (!ret)
 		ret = cmd->result;
 
-	rwnx_pm_relax(rwnx_hw->sdiodev);
+	rwnx_wakeup_unlock(rwnx_hw->ws_tx);
 	//return ret;
 	return 0;
 }
@@ -1115,6 +1116,7 @@ int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_v
 	return error;
 }
 
+#if 0
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en)
 {
 	struct mm_set_txop_req *req;
@@ -1138,6 +1140,111 @@ int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en
 
         return error;
 }
+#endif
+
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param)
+{
+	struct mm_set_acs_txop_req *req0;
+	struct mm_set_channel_access_req *req1;
+	struct mm_set_mac_timescale_req *req2;
+	struct mm_set_cca_threshold_req *req3;
+	struct mm_set_bwmode_req *req4;
+
+	int error;
+
+	switch (hwconfig_id)
+	{
+	    case ACS_TXOP_REQ:
+		/* Build the ACS_TXOP_REQ message */
+		req0= rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_acs_txop_req) );
+		if (!req0)
+		    return -ENOMEM;
+		req0->hwconfig_id = hwconfig_id;
+		req0->txop_be = param[0];
+		req0->txop_bk = param[1];
+		req0->txop_vi = param[2];
+		req0->txop_vo = param[3];
+		printk("set_acs_txop_req: be: %x,bk: %x,vi: %x,vo: %x\n",
+                        req0->txop_be, req0->txop_bk, req0->txop_vi, req0->txop_vo);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req0, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+		break;
+
+	    case CHANNEL_ACCESS_REQ:
+		/* Build the CHANNEL_ACCESS_REQ message */
+		req1 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_channel_access_req));
+		if (!req1)
+		    return -ENOMEM;
+		req1->hwconfig_id = hwconfig_id;
+		req1->edca[0] = param[0];
+		req1->edca[1] = param[1];
+		req1->edca[2] =	param[2];
+		req1->edca[3] = param[3];
+		req1->vif_idx = param[4];
+		req1->retry_cnt = param[5];
+		req1->rts_en = param[6];
+		req1->long_nav_en = param[7];
+		req1->cfe_en = param[8];
+		req1->rc_retry_cnt[0] = param[9];
+		req1->rc_retry_cnt[1] = param[10];
+		req1->rc_retry_cnt[2] = param[11];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2]);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+		break;
+
+	    case MAC_TIMESCALE_REQ:
+		/* Build the MAC_TIMESCALE_REQ message */
+		req2 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_mac_timescale_req));
+		if (!req2)
+		    return -ENOMEM;
+		req2->hwconfig_id = hwconfig_id;
+		req2->sifsA_time = param[0];
+		req2->sifsB_time = param[1];
+		req2->slot_time = param[2];
+		req2->rx_startdelay_ofdm = param[3];
+		req2->rx_startdelay_long = param[4];
+		req2->rx_startdelay_short = param[5];
+		printk("set_mac_timescale_req:sifsA_time: %x, sifsB_time: %x, slot_time: %x, rx_startdelay ofdm:%x long %x short %x\n",
+			req2->sifsA_time, req2->sifsB_time, req2->slot_time, req2->rx_startdelay_ofdm, req2->rx_startdelay_long, req2->rx_startdelay_short);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req2, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+		break;
+
+	    case CCA_THRESHOLD_REQ:
+		/* Build the CCA_THRESHOLD_REQ message */
+		req3 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_cca_threshold_req));
+		if (!req3)
+		    return -ENOMEM;
+		req3->hwconfig_id = hwconfig_id;
+	        req3->auto_cca_en = param[0];
+		req3->cca20p_rise_th = param[1];
+		req3->cca20s_rise_th = param[2];
+		req3->cca20p_fall_th = param[3];
+		req3->cca20s_fall_th = param[4];
+		printk("cca_threshold_req: auto_cca_en:%d\ncca20p_rise_th = %d\ncca20s_rise_th = %d\ncca20p_fall_th = %d\ncca20s_fall_th = %d\n",
+			req3->auto_cca_en, req3->cca20p_rise_th, req3->cca20s_rise_th, req3->cca20p_fall_th, req3->cca20s_fall_th);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req3, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+		break;
+	    case BWMODE_REQ:
+		/* Build the SET_BWMODE_REQ message */
+		req4 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_bwmode_req));
+		if (!req4)
+		    return -ENOMEM;
+		req4->hwconfig_id = hwconfig_id;
+		req4->bwmode = param[0];
+		printk("bwmode :%d\n", req4->bwmode);
+                /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+		break;
+	    default:
+		return -ENOMEM;
+	}
+    return error;
+}
+
 
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm)
 {
@@ -1245,7 +1352,10 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     struct mm_set_txpwr_lvl_req *txpwr_lvl_req;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3_tmp;
     txpwr_lvl_conf_v3_t *txpwr_lvl_v3;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+    txpwr_loss_conf_t *txpwr_loss;
     int error;
+	int i;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -1258,8 +1368,29 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     }
 
     txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
+    txpwr_loss = &txpwr_loss_tmp;
+    txpwr_loss->loss_enable = 0;
 
     get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_v3);
+    get_userconfig_txpwr_loss(txpwr_loss);
+
+    if (txpwr_loss->loss_enable == 1) {
+        AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n", __func__, txpwr_loss->loss_value);
+
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 9; i++)
+            txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11ax_2g4[i] += txpwr_loss->loss_value;
+
+		for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11a_5g[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 9; i++)
+            txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11ax_5g[i] += txpwr_loss->loss_value;
+    }
 
     if (txpwr_lvl_v3->enable == 0) {
         rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
@@ -1415,8 +1546,7 @@ int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
 	if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801){
 		get_userconfig_txpwr_ofst(txpwr_ofst);
 	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW  ||
-            rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+			rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
 		get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst);
 	}
 
@@ -1431,6 +1561,66 @@ int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
 	}
 };
 
+int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_ofst_req *txpwr_ofst_req;
+    txpwr_ofst2x_conf_t *txpwr_ofst2x;
+    int error = 0;
+    int type, ch_grp;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_OFST_REQ message */
+    txpwr_ofst_req = rwnx_msg_zalloc(MM_SET_TXPWR_OFST_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_ofst_req));
+
+    if (!txpwr_ofst_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_ofst2x = &txpwr_ofst_req->txpwr_ofst2x;
+    txpwr_ofst2x->enable = 0;
+    for (type = 0; type < 3; type++) {
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            if (ch_grp < 3) {
+                txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp] = 0;
+            }
+            txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp] = 0;
+        }
+    }
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+        get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
+    }
+    if (txpwr_ofst2x->enable){
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n", __func__, txpwr_ofst2x->enable);
+        AICWFDBG(LOGINFO, "pwrofst2x 2.4g: [0]:11b, [1]:ofdm_highrate, [2]:ofdm_lowrate\n"
+            "  chan=" "\t1-4" "\t5-9" "\t10-13");
+        for (type = 0; type < 3; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_lowrate, [1]:ofdm_highrate, [2]:ofdm_midrate\n"
+            "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+        for (type = 0; type < 3; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\n");
+
+        /* Send the MM_SET_TXPWR_OFST_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_ofst_req, 1, MM_SET_TXPWR_OFST_CFM, NULL);
+    }else{
+        AICWFDBG(LOGINFO, "%s:Do not use txpwr_ofst2x\r\n", __func__);
+        rwnx_msg_free(rwnx_hw, txpwr_ofst_req);
+    }
+
+    return (error);
+}
+
 /******************************************************************************
  *    Control messages handling functions (FULLMAC only)
  *****************************************************************************/
@@ -1640,10 +1830,15 @@ int rwnx_send_me_set_control_port_req(struct rwnx_hw *rwnx_hw, bool opened, u8 s
 int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *params,
 						 const u8 *mac, u8 inst_nbr, struct me_sta_add_cfm *cfm)
 {
-
-
 	struct me_sta_add_req *req;
-	u8 *ht_mcs = (u8 *)&params->ht_capa->mcs;
+    
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 41)
+    struct link_station_parameters *link_sta_params = &params->link_sta_params;
+#else
+    struct station_parameters *link_sta_params = params;
+#endif
+    u8 *ht_mcs = (u8 *)&link_sta_params->ht_capa->mcs;
+
 	int i;
 	struct rwnx_vif *rwnx_vif = rwnx_hw->vif_table[inst_nbr];
 	#if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
@@ -1667,13 +1862,13 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 	/* Set parameters for the MM_STA_ADD_REQ message */
 	memcpy(&(req->mac_addr.array[0]), mac, ETH_ALEN);
 
-	req->rate_set.length = params->supported_rates_len;
-	for (i = 0; i < params->supported_rates_len; i++)
-		req->rate_set.array[i] = params->supported_rates[i];
+	req->rate_set.length = link_sta_params->supported_rates_len;;
+	for (i = 0; i < link_sta_params->supported_rates_len; i++)
+		req->rate_set.array[i] = link_sta_params->supported_rates[i];
 
 	req->flags = 0;
-	if (params->ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->ht_capa;
+	if (link_sta_params->ht_capa) {
+		const struct ieee80211_ht_cap *ht_capa = link_sta_params->ht_capa;
 
 		req->flags |= STA_HT_CAPA;
 		req->ht_cap.ht_capa_info = cpu_to_le16(ht_capa->cap_info);
@@ -1686,8 +1881,8 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-    if (params->vht_capa) {
-        const struct ieee80211_vht_cap *vht_capa = params->vht_capa;
+    if (link_sta_params->vht_capa) {
+        const struct ieee80211_vht_cap *vht_capa = link_sta_params->vht_capa;
 
         req->flags |= STA_VHT_CAPA;
         req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
@@ -1710,8 +1905,8 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-	if (params->he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->he_capa;
+	if (link_sta_params->he_capa) {
+		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
 		struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
 								(struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -1759,9 +1954,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 		req->flags |= STA_MFP_CAPA;
 
 	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	if (params->opmode_notif_used) {
+	if (link_sta_params->opmode_notif_used) {
 		req->flags |= STA_OPMOD_NOTIF;
-		req->opmode = params->opmode_notif;
+		req->opmode = link_sta_params->opmode_notif_used;
 	}
 	#endif
 
@@ -2065,7 +2260,7 @@ int rwnx_send_sm_external_auth_required_rsp(struct rwnx_hw *rwnx_hw,
 	rsp->vif_idx = rwnx_vif->vif_index;
 
 	/* send the SM_EXTERNAL_AUTH_REQUIRED_RSP message UMAC FW */
-	return rwnx_send_msg(rwnx_hw, rsp, 0, 0, NULL);
+	return rwnx_send_msg(rwnx_hw, rsp, 1, SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM, NULL);
 }
 
 int rwnx_send_apm_start_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *vif,
@@ -3229,5 +3424,5 @@ int rwnx_send_cfg_rssi_req(struct rwnx_hw *rwnx_hw, u8 vif_index, int rssi_thold
 	req->rssi_hyst = (u8)rssi_hyst;
 
 	/* Send the MM_CFG_RSSI_REQ message to LMAC FW */
-	return rwnx_send_msg(rwnx_hw, req, 0, 0, NULL);
+	return rwnx_send_msg(rwnx_hw, req, 1, MM_CFG_RSSI_CFM, NULL);
 }
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
old mode 100755
new mode 100644
index b2753edd6..99f1017ca
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -166,9 +166,11 @@ int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
 					u8_l fwtrace_redir_en, struct mm_set_stack_start_cfm *cfm);
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en);
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param);
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm);
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mu_group.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_pci.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
old mode 100755
new mode 100644
index 50147545e..4ca92f8f3
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -55,7 +55,9 @@ typedef struct
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+	txpwr_loss_conf_t txpwr_loss;
     txpwr_ofst_conf_t txpwr_ofst;
+	txpwr_ofst2x_conf_t txpwr_ofst2x;
     xtal_cap_conf_t xtal_cap;
 } userconfig_info_t;
 
@@ -105,6 +107,10 @@ userconfig_info_t userconfig_info = {
             //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
             { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15,   14,   14},
     },
+	.txpwr_loss = {
+		.loss_enable	  = 1,
+		.loss_value 	  = 0,
+	},
     .txpwr_ofst = {
         .enable       = 1,
         .chan_1_4     = 0,
@@ -115,6 +121,21 @@ userconfig_info_t userconfig_info = {
         .chan_122_140 = 0,
         .chan_142_165 = 0,
     },
+    .txpwr_ofst2x = {
+        .enable       = 0,
+        .pwrofst2x_tbl_2g4 =
+        { // ch1-4, ch5-9, ch10-13
+            {   0,    0,    0   }, // 11b
+            {   0,    0,    0   }, // ofdm_highrate
+            {   0,    0,    0   }, // ofdm_lowrate
+        },
+        .pwrofst2x_tbl_5g =
+        { // ch42,  ch58, ch106,ch122,ch138,ch155
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_lowrate
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_highrate
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_midrate
+        },
+    },
     .xtal_cap = {
         .enable        = 0,
         .xtal_cap      = 24,
@@ -202,6 +223,10 @@ static int rwnx_plat_tl4_fw_upload(struct rwnx_plat *rwnx_plat, u8 *fw_addr,
 }
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
 #if 0
 /**
  * rwnx_plat_bin_fw_upload() - Load the requested binary FW into embedded side.
@@ -296,9 +321,9 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
     void *buffer = NULL;
     char *path = NULL;
     struct file *fp = NULL;
-    int size = 0, len = 0, i = 0;
+    int size = 0, len = 0;// i = 0;
     ssize_t rdlen = 0;
-    u32 *src = NULL, *dst = NULL;
+    //u32 *src = NULL, *dst = NULL;
 	MD5_CTX md5;
 	unsigned char decrypt[16];
 
@@ -371,6 +396,7 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
         fp->f_pos += rdlen;
     }
 
+#if 0
     /*start to transform the data format*/
     src = (u32 *)buffer;
     dst = (u32 *)kzalloc(size, GFP_KERNEL);
@@ -388,16 +414,17 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
     for (i = 0; i < (size/4); i++) {
         dst[i] = src[i];
     }
+#endif
 
     __putname(path);
     filp_close(fp, NULL);
     fp = NULL;
-    kfree(buffer);
-    buffer = NULL;
-    *fw_buf = dst;
+    //kfree(buffer);
+    //buffer = NULL;
+    *fw_buf = (u32*)buffer;
 
 	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Update(&md5, (unsigned char *)buffer, size);
 	MD5Final(&md5, decrypt);
 
 	AICWFDBG(LOGINFO, MD5PINRT, MD5(decrypt));
@@ -553,6 +580,29 @@ void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst)
     AICWFDBG(LOGINFO, "%s:chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
 }
 
+void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x)
+{
+    int type, ch_grp;
+    *txpwr_ofst2x = userconfig_info.txpwr_ofst2x;
+    AICWFDBG(LOGINFO, "%s:enable      :%d\r\n", __func__, txpwr_ofst2x->enable);
+    AICWFDBG(LOGINFO, "pwrofst2x 2.4g: [0]:11b, [1]:ofdm_highrate, [2]:ofdm_lowrate\n"
+        "  chan=" "\t1-4" "\t5-9" "\t10-13");
+    for (type = 0; type < 3; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_lowrate, [1]:ofdm_highrate, [2]:ofdm_midrate\n"
+        "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+    for (type = 0; type < 3; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\n");
+}
 
 void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx)
 {
@@ -566,8 +616,14 @@ void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst)
 
 void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
 {
-    *xtal_cap = nvram_info.xtal_cap;
-
+    if(nvram_info.xtal_cap.enable){
+        *xtal_cap = nvram_info.xtal_cap;
+    }
+    
+    if(userconfig_info.xtal_cap.enable){
+        *xtal_cap = userconfig_info.xtal_cap;
+    }
+    
     AICWFDBG(LOGINFO, "%s:enable       :%d\r\n", __func__, xtal_cap->enable);
     AICWFDBG(LOGINFO, "%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
     AICWFDBG(LOGINFO, "%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
@@ -984,8 +1040,13 @@ void rwnx_plat_nvram_set_value_v3(char *command, char *value)
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[10] = rwnx_atoi(value);
     } else if (!strcmp(command,     "lvl_11ax_mcs11_5g")) {
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[11] = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable")) {
+        userconfig_info.txpwr_loss.loss_enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value")) {
+        userconfig_info.txpwr_loss.loss_value = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_enable")) {
         userconfig_info.txpwr_ofst.enable = rwnx_atoi(value);
+		userconfig_info.txpwr_ofst2x.enable = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_1_4")) {
         userconfig_info.txpwr_ofst.chan_1_4 = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_5_9")) {
@@ -1000,6 +1061,60 @@ void rwnx_plat_nvram_set_value_v3(char *command, char *value)
         userconfig_info.txpwr_ofst.chan_122_140 = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_142_165")) {
         userconfig_info.txpwr_ofst.chan_142_165 = rwnx_atoi(value);
+	} else if (!strcmp(command, "ofst_2g4_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][1] = rwnx_atoi(value);
+	} else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][5] = rwnx_atoi(value);
     } else if (!strcmp(command, "xtal_enable")) {
         userconfig_info.xtal_cap.enable = rwnx_atoi(value);
     } else if (!strcmp(command, "xtal_cap")) {
@@ -1077,11 +1192,11 @@ void rwnx_plat_userconfig_parsing3(char *buffer, int size)
 {
     int i = 0;
     int parse_state = 0;
-    char command[30];
+    char command[64];
     char value[100];
     int char_counter = 0;
 
-    memset(command, 0, 30);
+    memset(command, 0, 64);
     memset(value, 0, 100);
 
     for (i = 0; i < size; i++) {
@@ -1095,7 +1210,7 @@ void rwnx_plat_userconfig_parsing3(char *buffer, int size)
                 }
             }
             //Reset command value and char_counter
-            memset(command, 0, 30);
+            memset(command, 0, 64);
             memset(value, 0, 100);
             char_counter = 0;
             parse_state = INIT;
@@ -1129,6 +1244,9 @@ void rwnx_plat_userconfig_parsing3(char *buffer, int size)
             command[char_counter] = buffer[i];
             char_counter++;
         } else if (parse_state == GET_VALUE) {
+            if(buffer[i] != 0x2D && (buffer[i] < 0x30 || buffer[i] > 0x39)) {
+                continue;
+            }
             value[char_counter] = buffer[i];
             char_counter++;
         }
@@ -1243,9 +1361,9 @@ static int aic_load_firmware(u32 ** fw_buf, char *fw_path,const char *name, stru
     void *buffer=NULL;
     char *path=NULL;
     struct file *fp=NULL;
-    int size = 0, len=0, i=0;
+    int size = 0, len=0;//, i=0;
     ssize_t rdlen=0;
-    u32 *src=NULL, *dst = NULL;
+    //u32 *src=NULL, *dst = NULL;
 
     /* get the firmware path */
     path = __getname();
@@ -1318,7 +1436,7 @@ static int aic_load_firmware(u32 ** fw_buf, char *fw_path,const char *name, stru
             //printk("f_pos=%d\n", (int)fp->f_pos);
     }
 
-
+#if 0
    /*start to transform the data format*/
     src = (u32*)buffer;
     //printk("malloc dst\n");
@@ -1338,13 +1456,14 @@ static int aic_load_firmware(u32 ** fw_buf, char *fw_path,const char *name, stru
     for(i=0;i<(size/4);i++){
             dst[i] = src[i];
     }
+#endif
 
     __putname(path);
     filp_close(fp,NULL);
     fp=NULL;
-    vfree(buffer);
-    buffer=NULL;
-    *fw_buf = dst;
+    //vfree(buffer);
+    //buffer=NULL;
+    *fw_buf = (u32 *)buffer;
 
     return size;
 #endif
@@ -1765,15 +1884,24 @@ static int rwnx_plat_userconfig_load(struct rwnx_hw *rwnx_hw) {
 	if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801){
 		
 		rwnx_plat_userconfig_upload_android(rwnx_hw, aic_fw_path, FW_USERCONFIG_NAME);
-	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC){
 		rwnx_plat_userconfig_load_8800dc(rwnx_hw);
-	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+        rwnx_plat_userconfig_load_8800dw(rwnx_hw);
+    }else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
 		rwnx_plat_userconfig_load_8800d80(rwnx_hw);
 	}
 	return 0;
 }
 
+void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss)
+{
+    txpwr_loss->loss_enable      = userconfig_info.txpwr_loss.loss_enable;
+    txpwr_loss->loss_value       = userconfig_info.txpwr_loss.loss_value;
+
+    AICWFDBG(LOGINFO, "%s:loss_enable:%d\r\n",     __func__, txpwr_loss->loss_enable);
+    AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n",      __func__, txpwr_loss->loss_value);
+}
 
 /**
  * rwnx_platform_on() - Start the platform
@@ -1940,5 +2068,3 @@ MODULE_FIRMWARE(RWNX_MAC_FW_NAME2);
 #endif
 
 
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
old mode 100755
new mode 100644
index 9cba3b20b..e5e8475eb
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -118,9 +118,10 @@ void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap);
 void get_userconfig_txpwr_lvl_in_fdrv(txpwr_lvl_conf_t *txpwr_lvl);
 void get_userconfig_txpwr_lvl_v2_in_fdrv(txpwr_lvl_conf_v2_t *txpwr_lvl_v2);
 void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3);
-void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst);
-
 
+void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst);
+void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x);
+void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss);
 extern struct device *rwnx_platform_get_dev(struct rwnx_plat *rwnx_plat);
 
 static inline unsigned int rwnx_platform_get_irq(struct rwnx_plat *rwnx_plat)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_prof.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
old mode 100755
new mode 100644
index 35a1923ae..5f650bc8f
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -110,8 +110,14 @@ struct rwnx_vif *rwnx_rx_get_vif(struct rwnx_hw *rwnx_hw, int vif_idx)
 
 	if (vif_idx < NX_VIRT_DEV_MAX) {
 		rwnx_vif = rwnx_hw->vif_table[vif_idx];
-		if (!rwnx_vif || !rwnx_vif->up)
-			return NULL;
+        
+        if(!rwnx_vif){
+            AICWFDBG(LOGERROR, "%s rwnx_hw->vif_table[%d] NULL\r\n", __func__, vif_idx);
+            return NULL;
+        }else if(!rwnx_vif->up){
+            AICWFDBG(LOGERROR, "%s rwnx_hw->vif_table[%d] is down\r\n", __func__, vif_idx);
+            return NULL;
+        }
 	}
 
 	return rwnx_vif;
@@ -405,7 +411,9 @@ static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *r
 	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 	REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
 	#ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
+	local_bh_disable();
 	netif_receive_skb(rx_skb);
+	local_bh_enable();
 	#else
 	if (in_interrupt()) {
 		netif_rx(rx_skb);
@@ -570,7 +578,9 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 			memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
             REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
             #ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
+            local_bh_disable();
 			netif_receive_skb(rx_skb);
+            local_bh_enable();
 			#else
 			if (in_interrupt()) {
 				netif_rx(rx_skb);
@@ -1202,8 +1212,10 @@ static int rwnx_rx_monitor(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_802_2);
-
+    
+    local_bh_disable();
 	netif_receive_skb(skb);
+    local_bh_enable();
 
 	return 0;
 }
@@ -1475,7 +1487,9 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
     memset(skb->cb, 0, sizeof(skb->cb));
 
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
+    local_bh_disable();
 	netif_receive_skb(skb);
+    local_bh_enable();
 #else
     if (in_interrupt()) {
         netif_rx(skb);
@@ -1495,8 +1509,8 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
 #endif
     }
 #endif//CONFIG_RX_NETIF_RECV_SKB
-    rwnx_vif->net_stats.rx_packets++;
-    rwnx_vif->net_stats.rx_bytes += skb->len;
+    //rwnx_vif->net_stats.rx_packets++;
+    //rwnx_vif->net_stats.rx_bytes += skb->len;
     prframe->pkt = NULL;
     reord_rxframe_free(&rx_priv->freeq_lock, rxframes_freequeue, &prframe->rxframe_list);
 
@@ -1582,11 +1596,14 @@ void reord_timeout_handler (struct timer_list *t)
 #else
 	struct reord_ctrl *preorder_ctrl = from_timer(preorder_ctrl, t, reord_timer);
 #endif
+
+#if 0 //AIDEN
 	struct aicwf_rx_priv *rx_priv = preorder_ctrl->rx_priv;
 
 	if (reord_rxframes_process(rx_priv, preorder_ctrl, true) == true) {
 		mod_timer(&preorder_ctrl->reord_timer, jiffies + msecs_to_jiffies(REORDER_UPDATE_TIME));
 	}
+#endif
 
 	if (!work_pending(&preorder_ctrl->reord_timer_work))
 		schedule_work(&preorder_ctrl->reord_timer_work);
@@ -1682,9 +1699,11 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 	spin_unlock_bh(&rx_priv->stas_reord_lock);
 
 	if (preorder_ctrl->enable == false) {
+        spin_lock_bh(&preorder_ctrl->reord_list_lock);
 		preorder_ctrl->ind_sn = pframe->seq_num;
 		reord_single_frame_ind(rx_priv, pframe);
 		preorder_ctrl->ind_sn = (preorder_ctrl->ind_sn + 1)%4096;
+        spin_unlock_bh(&rx_priv->stas_reord_lock);
 		return 0;
 	}
 
@@ -2035,6 +2054,10 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
 				pull_len += 4;//wep_header
 				memcpy(ether_type, &skb->data[hdr_len + 6 + 4], 2);
 				break;
+			case RWNX_RX_HD_DECR_WAPI:
+                                pull_len += 18;//wapi_header
+                                memcpy(ether_type, &skb->data[hdr_len + 6 + 18], 2);
+                                break;
 
 			default:
 				memcpy(ether_type, &skb->data[hdr_len + 6], 2);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
old mode 100755
new mode 100644
index 673d465fd..52ffbf64c
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
@@ -125,12 +125,15 @@ static const char *const rwnx_mmid2str[MSG_I(MM_MAX)] = {
     [MSG_I(MM_SET_STACK_START_REQ)] = "MM_SET_STACK_START_REQ",
     [MSG_I(MM_SET_STACK_START_CFM)] = "MM_SET_STACK_START_CFM",
     [MSG_I(MM_APM_STALOSS_IND)]     = "MM_APM_STALOSS_IND",
-    [MSG_I(MM_SET_TXOP_REQ)]        = "MM_SET_TXOP_REQ",
-    [MSG_I(MM_SET_TXOP_CFM)]        = "MM_SET_TXOP_CFM",
+    [MSG_I(MM_SET_VENDOR_HWCONFIG_REQ)] = "MM_SET_VENDOR_HWCONFIG_REQ",
+    [MSG_I(MM_SET_VENDOR_HWCONFIG_CFM)] = "MM_SET_VENDOR_HWCONFIG_CFM",
     [MSG_I(MM_GET_FW_VERSION_REQ)]  = "MM_GET_FW_VERSION_REQ",
     [MSG_I(MM_GET_FW_VERSION_CFM)]  = "MM_GET_FW_VERSION_CFM",
-    [MSG_I(MM_SET_VENDOR_TRX_PARAM_REQ)] = "MM_SET_VENDOR_TRX_PARAM_REQ",
-    [MSG_I(MM_SET_VENDOR_TRX_PARAM_CFM)] = "MM_SET_VENDOR_TRX_PARAM_CFM",
+    [MSG_I(MM_SET_RESUME_RESTORE_REQ)]          = "MM_SET_RESUME_RESTORE_REQ",
+    [MSG_I(MM_SET_RESUME_RESTORE_CFM)]          = "MM_SET_RESUME_RESTORE_CFM",
+    [MSG_I(MM_GET_WIFI_DISABLE_REQ)]            = "MM_GET_WIFI_DISABLE_REQ",
+    [MSG_I(MM_GET_WIFI_DISABLE_CFM)]            = "MM_GET_WIFI_DISABLE_CFM",
+    [MSG_I(MM_CFG_RSSI_CFM)]                    = "MM_CFG_RSSI_CFM",
 };
 
 static const char *const rwnx_dbgid2str[MSG_I(DBG_MAX)] = {
@@ -213,6 +216,7 @@ static const char *const rwnx_smid2str[MSG_I(SM_MAX)] = {
     [MSG_I(SM_DISCONNECT_IND)]    = "SM_DISCONNECT_IND",
     [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_IND)] = "SM_EXTERNAL_AUTH_REQUIRED_IND",
     [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_RSP)] = "SM_EXTERNAL_AUTH_REQUIRED_RSP",
+    [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM)] = "SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM",
 };
 
 static const char *const rwnx_apmid2str[MSG_I(APM_MAX)] = {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tdls.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_testmode.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
old mode 100755
new mode 100644
index feb6700f2..096d7ffe4
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -291,6 +291,13 @@ u16 rwnx_select_txq(struct rwnx_vif *rwnx_vif, struct sk_buff *skb)
 	struct rwnx_txq *txq;
 	u16 netdev_queue;
 	bool tdls_mgmgt_frame = false;
+    int nx_bcmc_txq_ndev_idx = NX_BCMC_TXQ_NDEV_IDX;
+
+    if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
+        ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+        g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
+            nx_bcmc_txq_ndev_idx = NX_BCMC_TXQ_NDEV_IDX_FOR_OLD_IC;
+    }
 
 	switch (wdev->iftype) {
 	case NL80211_IFTYPE_STATION:
@@ -421,10 +428,12 @@ u16 rwnx_select_txq(struct rwnx_vif *rwnx_vif, struct sk_buff *skb)
 		   for AP interface, select BCMC queue
 		   (TODO: select another queue if BCMC queue is stopped) */
 		skb->priority = PRIO_STA_NULL;
-		netdev_queue = NX_BCMC_TXQ_NDEV_IDX;
+		netdev_queue = nx_bcmc_txq_ndev_idx;
 	}
 
+#ifndef CONFIG_ONE_TXQ
 	BUG_ON(netdev_queue >= NX_NB_NDEV_TXQ);
+#endif
 
 	return netdev_queue;
 }
@@ -492,7 +501,6 @@ static struct rwnx_sta *rwnx_get_tx_priv(struct rwnx_vif *rwnx_vif,
 
 
     if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) ||
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) ||
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
             nx_remote_sta_max = NX_REMOTE_STA_MAX_FOR_OLD_IC;
@@ -1217,6 +1225,11 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	u8 tid;
 
 	struct ethhdr eth_t;
+
+#ifdef CONFIG_ONE_TXQ
+    skb->queue_mapping = rwnx_select_txq(rwnx_vif, skb);
+#endif
+
 	memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
 
 	sk_pacing_shift_update(skb->sk, rwnx_hw->tcp_pacing_shift);
@@ -1419,7 +1432,6 @@ int rwnx_start_mgmt_xmit(struct rwnx_vif *vif, struct rwnx_sta *sta,
 	#endif
 
     if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) ||
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) ||
         ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
             nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX_FOR_OLD_IC;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
old mode 100755
new mode 100644
index b5a1a3a4b..a0fd7a0f3
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
@@ -23,7 +23,6 @@ static inline int rwnx_txq_sta_idx(struct rwnx_sta *sta, u8 tid)
 {
 	if (is_multicast_sta(sta->sta_idx)){
         if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-            (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 			((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 			g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 			    return NX_FIRST_VIF_TXQ_IDX_FOR_OLD_IC + sta->vif_idx;
@@ -39,7 +38,6 @@ static inline int rwnx_txq_vif_idx(struct rwnx_vif *vif, u8 type)
 {
 
 	if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 		return NX_FIRST_VIF_TXQ_IDX_FOR_OLD_IC + master_vif_idx(vif) + (type * NX_VIRT_DEV_MAX);
@@ -102,7 +100,6 @@ static void rwnx_txq_init(struct rwnx_txq *txq, int idx, u8 status,
     int nx_first_vif_txq_idx = NX_FIRST_VIF_TXQ_IDX;
 
     if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 		    nx_first_unk_txq_idx = NX_FIRST_UNK_TXQ_IDX_FOR_OLD_IC;
@@ -350,7 +347,6 @@ void rwnx_txq_offchan_init(struct rwnx_vif *rwnx_vif)
     int nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX;
 
 	if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || 
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 		    nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX_FOR_OLD_IC;
@@ -376,7 +372,6 @@ void rwnx_txq_offchan_deinit(struct rwnx_vif *rwnx_vif)
     int nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX;
 
 	if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || 
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
 		    nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX_FOR_OLD_IC;
@@ -753,7 +748,6 @@ void rwnx_txq_offchan_start(struct rwnx_hw *rwnx_hw)
     int nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX;
 
 	if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) || 
-        (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) || 
 		((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
             nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX_FOR_OLD_IC;
@@ -854,6 +848,7 @@ int rwnx_txq_queue_skb(struct sk_buff *skb, struct rwnx_txq *txq,
 #endif
 	/* Flowctrl corresponding netdev queue if needed */
 #ifdef CONFIG_RWNX_FULLMAC
+#ifndef CONFIG_ONE_TXQ
 	/* If too many buffer are queued for this TXQ stop netdev queue */
 	if ((txq->ndev_idx != NDEV_NO_TXQ) &&
 		(skb_queue_len(&txq->sk_list) > RWNX_NDEV_FLOW_CTRL_STOP)) {
@@ -863,6 +858,7 @@ int rwnx_txq_queue_skb(struct sk_buff *skb, struct rwnx_txq *txq,
 		trace_txq_flowctrl_stop(txq);
 #endif
 	}
+#endif /* CONFIG_ONE_TXQ */
 #else /* ! CONFIG_RWNX_FULLMAC */
 
 	if (!retry && ++txq->hwq->len == txq->hwq->len_stop) {
@@ -1288,7 +1284,7 @@ void rwnx_hwq_process(struct rwnx_hw *rwnx_hw, struct rwnx_hwq *hwq)
 			}
 			/* for u-apsd need to complete the SP to send EOSP frame */
 		}
-
+#ifndef CONFIG_ONE_TXQ
 		/* restart netdev queue if number of queued buffer is below threshold */
 		if (unlikely(txq->status & RWNX_TXQ_NDEV_FLOW_CTRL) &&
 			skb_queue_len(&txq->sk_list) < RWNX_NDEV_FLOW_CTRL_RESTART) {
@@ -1298,6 +1294,7 @@ void rwnx_hwq_process(struct rwnx_hw *rwnx_hw, struct rwnx_hwq *hwq)
 			trace_txq_flowctrl_restart(txq);
 #endif
 		}
+#endif /* CONFIG_ONE_TXQ */
 #endif /* CONFIG_RWNX_FULLMAC */
 	}
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_v7.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
old mode 100755
new mode 100644
index 5b4aa62d8..6983ac8d5
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "241c091M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - - 241c091M (master)"
-#define RELEASE_DATE "2023_0207_1041"
+#define RELEASE_DATE "2023_0904_1725"
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
new file mode 100644
index 000000000..4f9b7ca23
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
@@ -0,0 +1,82 @@
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+#include <linux/pm_wakeirq.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include "rwnx_defs.h"
+#include "rwnx_wakelock.h"
+
+struct wakeup_source *rwnx_wakeup_init(const char *name)
+{
+	struct wakeup_source *ws;
+	ws = wakeup_source_create(name);
+	wakeup_source_add(ws);
+	return ws;
+}
+
+void rwnx_wakeup_deinit(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_remove(ws);
+	wakeup_source_destroy(ws);
+}
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+	return wakeup_source_register(dev, name);
+#else
+#ifdef CONFIG_PLATFORM_ROCKCHIP
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+    return wakeup_source_register(dev, name);
+#else
+    return wakeup_source_register(name);
+#endif
+#else
+	return wakeup_source_register(name);
+#endif//CONFIG_PLATFORM_ROCKCHIP
+#endif
+}
+
+void rwnx_wakeup_unregister(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_unregister(ws);
+}
+
+void rwnx_wakeup_lock(struct wakeup_source *ws)
+{
+	__pm_stay_awake(ws);
+}
+
+void rwnx_wakeup_unlock(struct wakeup_source *ws)
+{
+	__pm_relax(ws);
+}
+
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec)
+{
+	__pm_wakeup_event(ws, msec);
+}
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_hw->ws_tx = rwnx_wakeup_init("rwnx_tx_wakelock");
+	rwnx_hw->ws_rx = rwnx_wakeup_init("rwnx_rx_wakelock");
+    rwnx_hw->ws_irqrx = rwnx_wakeup_init("rwnx_irqrx_wakelock");
+	rwnx_hw->ws_pwrctrl = rwnx_wakeup_init("rwnx_pwrcrl_wakelock");
+}
+
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_wakeup_deinit(rwnx_hw->ws_tx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_rx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_irqrx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_pwrctrl);
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
new file mode 100644
index 000000000..9c9655a46
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
@@ -0,0 +1,21 @@
+#ifndef __RWNX_WAKELOCK_H
+#define __RWNX_WAKELOCK_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+
+struct wakeup_source *rwnx_wakeup_init(const char *name);
+void rwnx_wakeup_deinit(struct wakeup_source *ws);
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name);
+void rwnx_wakeup_unregister(struct wakeup_source *ws);
+
+void rwnx_wakeup_lock(struct wakeup_source *ws);
+void rwnx_wakeup_unlock(struct wakeup_source *ws);
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec);
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw);
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/sdio_host.h
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c b/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.c
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h b/drivers/net/wireless/aic8800/aic8800_fdrv/usb_host.h
old mode 100755
new mode 100644
-- 
2.35.8

